{"ast":null,"code":"import { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { splitEvery, splitHeader } from \"@smithy/core/serde\";\nimport { HttpRequest } from \"@smithy/protocol-http\";\nimport { sdkStreamMixin } from \"@smithy/util-stream\";\nimport { collectBody } from \"./collect-stream-body\";\nimport { extendedEncodeURIComponent } from \"./extended-encode-uri-component\";\nimport { HttpProtocol } from \"./HttpProtocol\";\nexport class HttpBindingProtocol extends HttpProtocol {\n  async serializeRequest(operationSchema, _input, context) {\n    const input = {\n      ...(_input ?? {})\n    };\n    const serializer = this.serializer;\n    const query = {};\n    const headers = {};\n    const endpoint = await context.endpoint();\n    const ns = NormalizedSchema.of(operationSchema?.input);\n    const schema = ns.getSchema();\n    let hasNonHttpBindingMember = false;\n    let payload;\n    const request = new HttpRequest({\n      protocol: \"\",\n      hostname: \"\",\n      port: undefined,\n      path: \"\",\n      fragment: undefined,\n      query: query,\n      headers: headers,\n      body: undefined\n    });\n    if (endpoint) {\n      this.updateServiceEndpoint(request, endpoint);\n      this.setHostPrefix(request, operationSchema, input);\n      const opTraits = NormalizedSchema.translateTraits(operationSchema.traits);\n      if (opTraits.http) {\n        request.method = opTraits.http[0];\n        const [path, search] = opTraits.http[1].split(\"?\");\n        if (request.path == \"/\") {\n          request.path = path;\n        } else {\n          request.path += path;\n        }\n        const traitSearchParams = new URLSearchParams(search ?? \"\");\n        Object.assign(query, Object.fromEntries(traitSearchParams));\n      }\n    }\n    for (const [memberName, memberNs] of ns.structIterator()) {\n      const memberTraits = memberNs.getMergedTraits() ?? {};\n      const inputMemberValue = input[memberName];\n      if (inputMemberValue == null) {\n        continue;\n      }\n      if (memberTraits.httpPayload) {\n        const isStreaming = memberNs.isStreaming();\n        if (isStreaming) {\n          const isEventStream = memberNs.isStructSchema();\n          if (isEventStream) {\n            throw new Error(\"serialization of event streams is not yet implemented\");\n          } else {\n            payload = inputMemberValue;\n          }\n        } else {\n          serializer.write(memberNs, inputMemberValue);\n          payload = serializer.flush();\n        }\n        delete input[memberName];\n      } else if (memberTraits.httpLabel) {\n        serializer.write(memberNs, inputMemberValue);\n        const replacement = serializer.flush();\n        if (request.path.includes(`{${memberName}+}`)) {\n          request.path = request.path.replace(`{${memberName}+}`, replacement.split(\"/\").map(extendedEncodeURIComponent).join(\"/\"));\n        } else if (request.path.includes(`{${memberName}}`)) {\n          request.path = request.path.replace(`{${memberName}}`, extendedEncodeURIComponent(replacement));\n        }\n        delete input[memberName];\n      } else if (memberTraits.httpHeader) {\n        serializer.write(memberNs, inputMemberValue);\n        headers[memberTraits.httpHeader.toLowerCase()] = String(serializer.flush());\n        delete input[memberName];\n      } else if (typeof memberTraits.httpPrefixHeaders === \"string\") {\n        for (const [key, val] of Object.entries(inputMemberValue)) {\n          const amalgam = memberTraits.httpPrefixHeaders + key;\n          serializer.write([memberNs.getValueSchema(), {\n            httpHeader: amalgam\n          }], val);\n          headers[amalgam.toLowerCase()] = serializer.flush();\n        }\n        delete input[memberName];\n      } else if (memberTraits.httpQuery || memberTraits.httpQueryParams) {\n        this.serializeQuery(memberNs, inputMemberValue, query);\n        delete input[memberName];\n      } else {\n        hasNonHttpBindingMember = true;\n      }\n    }\n    if (hasNonHttpBindingMember && input) {\n      serializer.write(schema, input);\n      payload = serializer.flush();\n    }\n    request.headers = headers;\n    request.query = query;\n    request.body = payload;\n    return request;\n  }\n  serializeQuery(ns, data, query) {\n    const serializer = this.serializer;\n    const traits = ns.getMergedTraits();\n    if (traits.httpQueryParams) {\n      for (const [key, val] of Object.entries(data)) {\n        if (!(key in query)) {\n          this.serializeQuery(NormalizedSchema.of([ns.getValueSchema(), {\n            ...traits,\n            httpQuery: key,\n            httpQueryParams: undefined\n          }]), val, query);\n        }\n      }\n      return;\n    }\n    if (ns.isListSchema()) {\n      const sparse = !!ns.getMergedTraits().sparse;\n      const buffer = [];\n      for (const item of data) {\n        serializer.write([ns.getValueSchema(), traits], item);\n        const serializable = serializer.flush();\n        if (sparse || serializable !== undefined) {\n          buffer.push(serializable);\n        }\n      }\n      query[traits.httpQuery] = buffer;\n    } else {\n      serializer.write([ns, traits], data);\n      query[traits.httpQuery] = serializer.flush();\n    }\n  }\n  async deserializeResponse(operationSchema, context, response) {\n    const deserializer = this.deserializer;\n    const ns = NormalizedSchema.of(operationSchema.output);\n    const dataObject = {};\n    if (response.statusCode >= 300) {\n      const bytes = await collectBody(response.body, context);\n      if (bytes.byteLength > 0) {\n        Object.assign(dataObject, await deserializer.read(SCHEMA.DOCUMENT, bytes));\n      }\n      await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));\n      throw new Error(\"@smithy/core/protocols - HTTP Protocol error handler failed to throw.\");\n    }\n    for (const header in response.headers) {\n      const value = response.headers[header];\n      delete response.headers[header];\n      response.headers[header.toLowerCase()] = value;\n    }\n    const nonHttpBindingMembers = await this.deserializeHttpMessage(ns, context, response, dataObject);\n    if (nonHttpBindingMembers.length) {\n      const bytes = await collectBody(response.body, context);\n      if (bytes.byteLength > 0) {\n        const dataFromBody = await deserializer.read(ns, bytes);\n        for (const member of nonHttpBindingMembers) {\n          dataObject[member] = dataFromBody[member];\n        }\n      }\n    }\n    const output = {\n      $metadata: this.deserializeMetadata(response),\n      ...dataObject\n    };\n    return output;\n  }\n  async deserializeHttpMessage(schema, context, response, arg4, arg5) {\n    let dataObject;\n    if (arg4 instanceof Set) {\n      dataObject = arg5;\n    } else {\n      dataObject = arg4;\n    }\n    const deserializer = this.deserializer;\n    const ns = NormalizedSchema.of(schema);\n    const nonHttpBindingMembers = [];\n    for (const [memberName, memberSchema] of ns.structIterator()) {\n      const memberTraits = memberSchema.getMemberTraits();\n      if (memberTraits.httpPayload) {\n        const isStreaming = memberSchema.isStreaming();\n        if (isStreaming) {\n          const isEventStream = memberSchema.isStructSchema();\n          if (isEventStream) {\n            const context = this.serdeContext;\n            if (!context.eventStreamMarshaller) {\n              throw new Error(\"@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext.\");\n            }\n            const memberSchemas = memberSchema.getMemberSchemas();\n            dataObject[memberName] = context.eventStreamMarshaller.deserialize(response.body, async event => {\n              const unionMember = Object.keys(event).find(key => {\n                return key !== \"__type\";\n              }) ?? \"\";\n              if (unionMember in memberSchemas) {\n                const eventStreamSchema = memberSchemas[unionMember];\n                return {\n                  [unionMember]: await deserializer.read(eventStreamSchema, event[unionMember].body)\n                };\n              } else {\n                return {\n                  $unknown: event\n                };\n              }\n            });\n          } else {\n            dataObject[memberName] = sdkStreamMixin(response.body);\n          }\n        } else if (response.body) {\n          const bytes = await collectBody(response.body, context);\n          if (bytes.byteLength > 0) {\n            dataObject[memberName] = await deserializer.read(memberSchema, bytes);\n          }\n        }\n      } else if (memberTraits.httpHeader) {\n        const key = String(memberTraits.httpHeader).toLowerCase();\n        const value = response.headers[key];\n        if (null != value) {\n          if (memberSchema.isListSchema()) {\n            const headerListValueSchema = memberSchema.getValueSchema();\n            let sections;\n            if (headerListValueSchema.isTimestampSchema() && headerListValueSchema.getSchema() === SCHEMA.TIMESTAMP_DEFAULT) {\n              sections = splitEvery(value, \",\", 2);\n            } else {\n              sections = splitHeader(value);\n            }\n            const list = [];\n            for (const section of sections) {\n              list.push(await deserializer.read([headerListValueSchema, {\n                httpHeader: key\n              }], section.trim()));\n            }\n            dataObject[memberName] = list;\n          } else {\n            dataObject[memberName] = await deserializer.read(memberSchema, value);\n          }\n        }\n      } else if (memberTraits.httpPrefixHeaders !== undefined) {\n        dataObject[memberName] = {};\n        for (const [header, value] of Object.entries(response.headers)) {\n          if (header.startsWith(memberTraits.httpPrefixHeaders)) {\n            dataObject[memberName][header.slice(memberTraits.httpPrefixHeaders.length)] = await deserializer.read([memberSchema.getValueSchema(), {\n              httpHeader: header\n            }], value);\n          }\n        }\n      } else if (memberTraits.httpResponseCode) {\n        dataObject[memberName] = response.statusCode;\n      } else {\n        nonHttpBindingMembers.push(memberName);\n      }\n    }\n    return nonHttpBindingMembers;\n  }\n}","map":{"version":3,"names":["NormalizedSchema","SCHEMA","splitEvery","splitHeader","HttpRequest","sdkStreamMixin","collectBody","extendedEncodeURIComponent","HttpProtocol","HttpBindingProtocol","serializeRequest","operationSchema","_input","context","input","serializer","query","headers","endpoint","ns","of","schema","getSchema","hasNonHttpBindingMember","payload","request","protocol","hostname","port","undefined","path","fragment","body","updateServiceEndpoint","setHostPrefix","opTraits","translateTraits","traits","http","method","search","split","traitSearchParams","URLSearchParams","Object","assign","fromEntries","memberName","memberNs","structIterator","memberTraits","getMergedTraits","inputMemberValue","httpPayload","isStreaming","isEventStream","isStructSchema","Error","write","flush","httpLabel","replacement","includes","replace","map","join","httpHeader","toLowerCase","String","httpPrefixHeaders","key","val","entries","amalgam","getValueSchema","httpQuery","httpQueryParams","serializeQuery","data","isListSchema","sparse","buffer","item","serializable","push","deserializeResponse","response","deserializer","output","dataObject","statusCode","bytes","byteLength","read","DOCUMENT","handleError","deserializeMetadata","header","value","nonHttpBindingMembers","deserializeHttpMessage","length","dataFromBody","member","$metadata","arg4","arg5","Set","memberSchema","getMemberTraits","serdeContext","eventStreamMarshaller","memberSchemas","getMemberSchemas","deserialize","event","unionMember","keys","find","eventStreamSchema","$unknown","headerListValueSchema","sections","isTimestampSchema","TIMESTAMP_DEFAULT","list","section","trim","startsWith","slice","httpResponseCode"],"sources":["/Users/tuvyakhatter/Desktop/pipecat_voicebot/~/Desktop/sow_editor/node_modules/@smithy/core/dist-es/submodules/protocols/HttpBindingProtocol.js"],"sourcesContent":["import { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { splitEvery, splitHeader } from \"@smithy/core/serde\";\nimport { HttpRequest } from \"@smithy/protocol-http\";\nimport { sdkStreamMixin } from \"@smithy/util-stream\";\nimport { collectBody } from \"./collect-stream-body\";\nimport { extendedEncodeURIComponent } from \"./extended-encode-uri-component\";\nimport { HttpProtocol } from \"./HttpProtocol\";\nexport class HttpBindingProtocol extends HttpProtocol {\n    async serializeRequest(operationSchema, _input, context) {\n        const input = {\n            ...(_input ?? {}),\n        };\n        const serializer = this.serializer;\n        const query = {};\n        const headers = {};\n        const endpoint = await context.endpoint();\n        const ns = NormalizedSchema.of(operationSchema?.input);\n        const schema = ns.getSchema();\n        let hasNonHttpBindingMember = false;\n        let payload;\n        const request = new HttpRequest({\n            protocol: \"\",\n            hostname: \"\",\n            port: undefined,\n            path: \"\",\n            fragment: undefined,\n            query: query,\n            headers: headers,\n            body: undefined,\n        });\n        if (endpoint) {\n            this.updateServiceEndpoint(request, endpoint);\n            this.setHostPrefix(request, operationSchema, input);\n            const opTraits = NormalizedSchema.translateTraits(operationSchema.traits);\n            if (opTraits.http) {\n                request.method = opTraits.http[0];\n                const [path, search] = opTraits.http[1].split(\"?\");\n                if (request.path == \"/\") {\n                    request.path = path;\n                }\n                else {\n                    request.path += path;\n                }\n                const traitSearchParams = new URLSearchParams(search ?? \"\");\n                Object.assign(query, Object.fromEntries(traitSearchParams));\n            }\n        }\n        for (const [memberName, memberNs] of ns.structIterator()) {\n            const memberTraits = memberNs.getMergedTraits() ?? {};\n            const inputMemberValue = input[memberName];\n            if (inputMemberValue == null) {\n                continue;\n            }\n            if (memberTraits.httpPayload) {\n                const isStreaming = memberNs.isStreaming();\n                if (isStreaming) {\n                    const isEventStream = memberNs.isStructSchema();\n                    if (isEventStream) {\n                        throw new Error(\"serialization of event streams is not yet implemented\");\n                    }\n                    else {\n                        payload = inputMemberValue;\n                    }\n                }\n                else {\n                    serializer.write(memberNs, inputMemberValue);\n                    payload = serializer.flush();\n                }\n                delete input[memberName];\n            }\n            else if (memberTraits.httpLabel) {\n                serializer.write(memberNs, inputMemberValue);\n                const replacement = serializer.flush();\n                if (request.path.includes(`{${memberName}+}`)) {\n                    request.path = request.path.replace(`{${memberName}+}`, replacement.split(\"/\").map(extendedEncodeURIComponent).join(\"/\"));\n                }\n                else if (request.path.includes(`{${memberName}}`)) {\n                    request.path = request.path.replace(`{${memberName}}`, extendedEncodeURIComponent(replacement));\n                }\n                delete input[memberName];\n            }\n            else if (memberTraits.httpHeader) {\n                serializer.write(memberNs, inputMemberValue);\n                headers[memberTraits.httpHeader.toLowerCase()] = String(serializer.flush());\n                delete input[memberName];\n            }\n            else if (typeof memberTraits.httpPrefixHeaders === \"string\") {\n                for (const [key, val] of Object.entries(inputMemberValue)) {\n                    const amalgam = memberTraits.httpPrefixHeaders + key;\n                    serializer.write([memberNs.getValueSchema(), { httpHeader: amalgam }], val);\n                    headers[amalgam.toLowerCase()] = serializer.flush();\n                }\n                delete input[memberName];\n            }\n            else if (memberTraits.httpQuery || memberTraits.httpQueryParams) {\n                this.serializeQuery(memberNs, inputMemberValue, query);\n                delete input[memberName];\n            }\n            else {\n                hasNonHttpBindingMember = true;\n            }\n        }\n        if (hasNonHttpBindingMember && input) {\n            serializer.write(schema, input);\n            payload = serializer.flush();\n        }\n        request.headers = headers;\n        request.query = query;\n        request.body = payload;\n        return request;\n    }\n    serializeQuery(ns, data, query) {\n        const serializer = this.serializer;\n        const traits = ns.getMergedTraits();\n        if (traits.httpQueryParams) {\n            for (const [key, val] of Object.entries(data)) {\n                if (!(key in query)) {\n                    this.serializeQuery(NormalizedSchema.of([\n                        ns.getValueSchema(),\n                        {\n                            ...traits,\n                            httpQuery: key,\n                            httpQueryParams: undefined,\n                        },\n                    ]), val, query);\n                }\n            }\n            return;\n        }\n        if (ns.isListSchema()) {\n            const sparse = !!ns.getMergedTraits().sparse;\n            const buffer = [];\n            for (const item of data) {\n                serializer.write([ns.getValueSchema(), traits], item);\n                const serializable = serializer.flush();\n                if (sparse || serializable !== undefined) {\n                    buffer.push(serializable);\n                }\n            }\n            query[traits.httpQuery] = buffer;\n        }\n        else {\n            serializer.write([ns, traits], data);\n            query[traits.httpQuery] = serializer.flush();\n        }\n    }\n    async deserializeResponse(operationSchema, context, response) {\n        const deserializer = this.deserializer;\n        const ns = NormalizedSchema.of(operationSchema.output);\n        const dataObject = {};\n        if (response.statusCode >= 300) {\n            const bytes = await collectBody(response.body, context);\n            if (bytes.byteLength > 0) {\n                Object.assign(dataObject, await deserializer.read(SCHEMA.DOCUMENT, bytes));\n            }\n            await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));\n            throw new Error(\"@smithy/core/protocols - HTTP Protocol error handler failed to throw.\");\n        }\n        for (const header in response.headers) {\n            const value = response.headers[header];\n            delete response.headers[header];\n            response.headers[header.toLowerCase()] = value;\n        }\n        const nonHttpBindingMembers = await this.deserializeHttpMessage(ns, context, response, dataObject);\n        if (nonHttpBindingMembers.length) {\n            const bytes = await collectBody(response.body, context);\n            if (bytes.byteLength > 0) {\n                const dataFromBody = await deserializer.read(ns, bytes);\n                for (const member of nonHttpBindingMembers) {\n                    dataObject[member] = dataFromBody[member];\n                }\n            }\n        }\n        const output = {\n            $metadata: this.deserializeMetadata(response),\n            ...dataObject,\n        };\n        return output;\n    }\n    async deserializeHttpMessage(schema, context, response, arg4, arg5) {\n        let dataObject;\n        if (arg4 instanceof Set) {\n            dataObject = arg5;\n        }\n        else {\n            dataObject = arg4;\n        }\n        const deserializer = this.deserializer;\n        const ns = NormalizedSchema.of(schema);\n        const nonHttpBindingMembers = [];\n        for (const [memberName, memberSchema] of ns.structIterator()) {\n            const memberTraits = memberSchema.getMemberTraits();\n            if (memberTraits.httpPayload) {\n                const isStreaming = memberSchema.isStreaming();\n                if (isStreaming) {\n                    const isEventStream = memberSchema.isStructSchema();\n                    if (isEventStream) {\n                        const context = this.serdeContext;\n                        if (!context.eventStreamMarshaller) {\n                            throw new Error(\"@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext.\");\n                        }\n                        const memberSchemas = memberSchema.getMemberSchemas();\n                        dataObject[memberName] = context.eventStreamMarshaller.deserialize(response.body, async (event) => {\n                            const unionMember = Object.keys(event).find((key) => {\n                                return key !== \"__type\";\n                            }) ?? \"\";\n                            if (unionMember in memberSchemas) {\n                                const eventStreamSchema = memberSchemas[unionMember];\n                                return {\n                                    [unionMember]: await deserializer.read(eventStreamSchema, event[unionMember].body),\n                                };\n                            }\n                            else {\n                                return {\n                                    $unknown: event,\n                                };\n                            }\n                        });\n                    }\n                    else {\n                        dataObject[memberName] = sdkStreamMixin(response.body);\n                    }\n                }\n                else if (response.body) {\n                    const bytes = await collectBody(response.body, context);\n                    if (bytes.byteLength > 0) {\n                        dataObject[memberName] = await deserializer.read(memberSchema, bytes);\n                    }\n                }\n            }\n            else if (memberTraits.httpHeader) {\n                const key = String(memberTraits.httpHeader).toLowerCase();\n                const value = response.headers[key];\n                if (null != value) {\n                    if (memberSchema.isListSchema()) {\n                        const headerListValueSchema = memberSchema.getValueSchema();\n                        let sections;\n                        if (headerListValueSchema.isTimestampSchema() &&\n                            headerListValueSchema.getSchema() === SCHEMA.TIMESTAMP_DEFAULT) {\n                            sections = splitEvery(value, \",\", 2);\n                        }\n                        else {\n                            sections = splitHeader(value);\n                        }\n                        const list = [];\n                        for (const section of sections) {\n                            list.push(await deserializer.read([headerListValueSchema, { httpHeader: key }], section.trim()));\n                        }\n                        dataObject[memberName] = list;\n                    }\n                    else {\n                        dataObject[memberName] = await deserializer.read(memberSchema, value);\n                    }\n                }\n            }\n            else if (memberTraits.httpPrefixHeaders !== undefined) {\n                dataObject[memberName] = {};\n                for (const [header, value] of Object.entries(response.headers)) {\n                    if (header.startsWith(memberTraits.httpPrefixHeaders)) {\n                        dataObject[memberName][header.slice(memberTraits.httpPrefixHeaders.length)] = await deserializer.read([memberSchema.getValueSchema(), { httpHeader: header }], value);\n                    }\n                }\n            }\n            else if (memberTraits.httpResponseCode) {\n                dataObject[memberName] = response.statusCode;\n            }\n            else {\n                nonHttpBindingMembers.push(memberName);\n            }\n        }\n        return nonHttpBindingMembers;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}