{"ast":null,"code":"import { XmlNode, XmlText } from \"@aws-sdk/xml-builder\";\nimport { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { generateIdempotencyToken, NumericValue } from \"@smithy/core/serde\";\nimport { dateToUtcString } from \"@smithy/smithy-client\";\nimport { fromBase64, toBase64 } from \"@smithy/util-base64\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nexport class XmlShapeSerializer extends SerdeContextConfig {\n  settings;\n  stringBuffer;\n  byteBuffer;\n  buffer;\n  constructor(settings) {\n    super();\n    this.settings = settings;\n  }\n  write(schema, value) {\n    const ns = NormalizedSchema.of(schema);\n    if (ns.isStringSchema() && typeof value === \"string\") {\n      this.stringBuffer = value;\n    } else if (ns.isBlobSchema()) {\n      this.byteBuffer = \"byteLength\" in value ? value : (this.serdeContext?.base64Decoder ?? fromBase64)(value);\n    } else {\n      this.buffer = this.writeStruct(ns, value, undefined);\n      const traits = ns.getMergedTraits();\n      if (traits.httpPayload && !traits.xmlName) {\n        this.buffer.withName(ns.getName());\n      }\n    }\n  }\n  flush() {\n    if (this.byteBuffer !== undefined) {\n      const bytes = this.byteBuffer;\n      delete this.byteBuffer;\n      return bytes;\n    }\n    if (this.stringBuffer !== undefined) {\n      const str = this.stringBuffer;\n      delete this.stringBuffer;\n      return str;\n    }\n    const buffer = this.buffer;\n    if (this.settings.xmlNamespace) {\n      if (!buffer?.attributes?.[\"xmlns\"]) {\n        buffer.addAttribute(\"xmlns\", this.settings.xmlNamespace);\n      }\n    }\n    delete this.buffer;\n    return buffer.toString();\n  }\n  writeStruct(ns, value, parentXmlns) {\n    const traits = ns.getMergedTraits();\n    const name = ns.isMemberSchema() && !traits.httpPayload ? ns.getMemberTraits().xmlName ?? ns.getMemberName() : traits.xmlName ?? ns.getName();\n    if (!name || !ns.isStructSchema()) {\n      throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${ns.getName(true)}.`);\n    }\n    const structXmlNode = XmlNode.of(name);\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n    if (xmlns) {\n      structXmlNode.addAttribute(xmlnsAttr, xmlns);\n    }\n    for (const [memberName, memberSchema] of ns.structIterator()) {\n      const val = value[memberName];\n      if (val != null || memberSchema.isIdempotencyToken()) {\n        if (memberSchema.getMergedTraits().xmlAttribute) {\n          structXmlNode.addAttribute(memberSchema.getMergedTraits().xmlName ?? memberName, this.writeSimple(memberSchema, val));\n          continue;\n        }\n        if (memberSchema.isListSchema()) {\n          this.writeList(memberSchema, val, structXmlNode, xmlns);\n        } else if (memberSchema.isMapSchema()) {\n          this.writeMap(memberSchema, val, structXmlNode, xmlns);\n        } else if (memberSchema.isStructSchema()) {\n          structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));\n        } else {\n          const memberNode = XmlNode.of(memberSchema.getMergedTraits().xmlName ?? memberSchema.getMemberName());\n          this.writeSimpleInto(memberSchema, val, memberNode, xmlns);\n          structXmlNode.addChildNode(memberNode);\n        }\n      }\n    }\n    return structXmlNode;\n  }\n  writeList(listMember, array, container, parentXmlns) {\n    if (!listMember.isMemberSchema()) {\n      throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${listMember.getName(true)}`);\n    }\n    const listTraits = listMember.getMergedTraits();\n    const listValueSchema = listMember.getValueSchema();\n    const listValueTraits = listValueSchema.getMergedTraits();\n    const sparse = !!listValueTraits.sparse;\n    const flat = !!listTraits.xmlFlattened;\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);\n    const writeItem = (container, value) => {\n      if (listValueSchema.isListSchema()) {\n        this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container, xmlns);\n      } else if (listValueSchema.isMapSchema()) {\n        this.writeMap(listValueSchema, value, container, xmlns);\n      } else if (listValueSchema.isStructSchema()) {\n        const struct = this.writeStruct(listValueSchema, value, xmlns);\n        container.addChildNode(struct.withName(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? \"member\"));\n      } else {\n        const listItemNode = XmlNode.of(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? \"member\");\n        this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);\n        container.addChildNode(listItemNode);\n      }\n    };\n    if (flat) {\n      for (const value of array) {\n        if (sparse || value != null) {\n          writeItem(container, value);\n        }\n      }\n    } else {\n      const listNode = XmlNode.of(listTraits.xmlName ?? listMember.getMemberName());\n      if (xmlns) {\n        listNode.addAttribute(xmlnsAttr, xmlns);\n      }\n      for (const value of array) {\n        if (sparse || value != null) {\n          writeItem(listNode, value);\n        }\n      }\n      container.addChildNode(listNode);\n    }\n  }\n  writeMap(mapMember, map, container, parentXmlns, containerIsMap = false) {\n    if (!mapMember.isMemberSchema()) {\n      throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${mapMember.getName(true)}`);\n    }\n    const mapTraits = mapMember.getMergedTraits();\n    const mapKeySchema = mapMember.getKeySchema();\n    const mapKeyTraits = mapKeySchema.getMergedTraits();\n    const keyTag = mapKeyTraits.xmlName ?? \"key\";\n    const mapValueSchema = mapMember.getValueSchema();\n    const mapValueTraits = mapValueSchema.getMergedTraits();\n    const valueTag = mapValueTraits.xmlName ?? \"value\";\n    const sparse = !!mapValueTraits.sparse;\n    const flat = !!mapTraits.xmlFlattened;\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);\n    const addKeyValue = (entry, key, val) => {\n      const keyNode = XmlNode.of(keyTag, key);\n      const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);\n      if (keyXmlns) {\n        keyNode.addAttribute(keyXmlnsAttr, keyXmlns);\n      }\n      entry.addChildNode(keyNode);\n      let valueNode = XmlNode.of(valueTag);\n      if (mapValueSchema.isListSchema()) {\n        this.writeList(mapValueSchema, val, valueNode, xmlns);\n      } else if (mapValueSchema.isMapSchema()) {\n        this.writeMap(mapValueSchema, val, valueNode, xmlns, true);\n      } else if (mapValueSchema.isStructSchema()) {\n        valueNode = this.writeStruct(mapValueSchema, val, xmlns);\n      } else {\n        this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);\n      }\n      entry.addChildNode(valueNode);\n    };\n    if (flat) {\n      for (const [key, val] of Object.entries(map)) {\n        if (sparse || val != null) {\n          const entry = XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());\n          addKeyValue(entry, key, val);\n          container.addChildNode(entry);\n        }\n      }\n    } else {\n      let mapNode;\n      if (!containerIsMap) {\n        mapNode = XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());\n        if (xmlns) {\n          mapNode.addAttribute(xmlnsAttr, xmlns);\n        }\n        container.addChildNode(mapNode);\n      }\n      for (const [key, val] of Object.entries(map)) {\n        if (sparse || val != null) {\n          const entry = XmlNode.of(\"entry\");\n          addKeyValue(entry, key, val);\n          (containerIsMap ? container : mapNode).addChildNode(entry);\n        }\n      }\n    }\n  }\n  writeSimple(_schema, value) {\n    if (null === value) {\n      throw new Error(\"@aws-sdk/core/protocols - (XML serializer) cannot write null value.\");\n    }\n    const ns = NormalizedSchema.of(_schema);\n    let nodeContents = null;\n    if (value && typeof value === \"object\") {\n      if (ns.isBlobSchema()) {\n        nodeContents = (this.serdeContext?.base64Encoder ?? toBase64)(value);\n      } else if (ns.isTimestampSchema() && value instanceof Date) {\n        const options = this.settings.timestampFormat;\n        const format = options.useTrait ? ns.getSchema() === SCHEMA.TIMESTAMP_DEFAULT ? options.default : ns.getSchema() ?? options.default : options.default;\n        switch (format) {\n          case SCHEMA.TIMESTAMP_DATE_TIME:\n            nodeContents = value.toISOString().replace(\".000Z\", \"Z\");\n            break;\n          case SCHEMA.TIMESTAMP_HTTP_DATE:\n            nodeContents = dateToUtcString(value);\n            break;\n          case SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n            nodeContents = String(value.getTime() / 1000);\n            break;\n          default:\n            console.warn(\"Missing timestamp format, using http date\", value);\n            nodeContents = dateToUtcString(value);\n            break;\n        }\n      } else if (ns.isBigDecimalSchema() && value) {\n        if (value instanceof NumericValue) {\n          return value.string;\n        }\n        return String(value);\n      } else if (ns.isMapSchema() || ns.isListSchema()) {\n        throw new Error(\"@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.\");\n      } else {\n        throw new Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${ns.getName(true)}`);\n      }\n    }\n    if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isBigIntegerSchema() || ns.isBigDecimalSchema()) {\n      nodeContents = String(value);\n    }\n    if (ns.isStringSchema()) {\n      if (value === undefined && ns.isIdempotencyToken()) {\n        nodeContents = generateIdempotencyToken();\n      } else {\n        nodeContents = String(value);\n      }\n    }\n    if (nodeContents === null) {\n      throw new Error(`Unhandled schema-value pair ${ns.getName(true)}=${value}`);\n    }\n    return nodeContents;\n  }\n  writeSimpleInto(_schema, value, into, parentXmlns) {\n    const nodeContents = this.writeSimple(_schema, value);\n    const ns = NormalizedSchema.of(_schema);\n    const content = new XmlText(nodeContents);\n    const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n    if (xmlns) {\n      into.addAttribute(xmlnsAttr, xmlns);\n    }\n    into.addChildNode(content);\n  }\n  getXmlnsAttribute(ns, parentXmlns) {\n    const traits = ns.getMergedTraits();\n    const [prefix, xmlns] = traits.xmlNamespace ?? [];\n    if (xmlns && xmlns !== parentXmlns) {\n      return [prefix ? `xmlns:${prefix}` : \"xmlns\", xmlns];\n    }\n    return [void 0, void 0];\n  }\n}","map":{"version":3,"names":["XmlNode","XmlText","NormalizedSchema","SCHEMA","generateIdempotencyToken","NumericValue","dateToUtcString","fromBase64","toBase64","SerdeContextConfig","XmlShapeSerializer","settings","stringBuffer","byteBuffer","buffer","constructor","write","schema","value","ns","of","isStringSchema","isBlobSchema","serdeContext","base64Decoder","writeStruct","undefined","traits","getMergedTraits","httpPayload","xmlName","withName","getName","flush","bytes","str","xmlNamespace","attributes","addAttribute","toString","parentXmlns","name","isMemberSchema","getMemberTraits","getMemberName","isStructSchema","Error","structXmlNode","xmlnsAttr","xmlns","getXmlnsAttribute","memberName","memberSchema","structIterator","val","isIdempotencyToken","xmlAttribute","writeSimple","isListSchema","writeList","isMapSchema","writeMap","addChildNode","memberNode","writeSimpleInto","listMember","array","container","listTraits","listValueSchema","getValueSchema","listValueTraits","sparse","flat","xmlFlattened","writeItem","Array","isArray","struct","listItemNode","listNode","mapMember","map","containerIsMap","mapTraits","mapKeySchema","getKeySchema","mapKeyTraits","keyTag","mapValueSchema","mapValueTraits","valueTag","addKeyValue","entry","key","keyNode","keyXmlnsAttr","keyXmlns","valueNode","Object","entries","mapNode","_schema","nodeContents","base64Encoder","isTimestampSchema","Date","options","timestampFormat","format","useTrait","getSchema","TIMESTAMP_DEFAULT","default","TIMESTAMP_DATE_TIME","toISOString","replace","TIMESTAMP_HTTP_DATE","TIMESTAMP_EPOCH_SECONDS","String","getTime","console","warn","isBigDecimalSchema","string","isBooleanSchema","isNumericSchema","isBigIntegerSchema","into","content","prefix"],"sources":["/Users/tuvyakhatter/Desktop/pipecat_voicebot/~/Desktop/sow_editor/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeSerializer.js"],"sourcesContent":["import { XmlNode, XmlText } from \"@aws-sdk/xml-builder\";\nimport { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { generateIdempotencyToken, NumericValue } from \"@smithy/core/serde\";\nimport { dateToUtcString } from \"@smithy/smithy-client\";\nimport { fromBase64, toBase64 } from \"@smithy/util-base64\";\nimport { SerdeContextConfig } from \"../ConfigurableSerdeContext\";\nexport class XmlShapeSerializer extends SerdeContextConfig {\n    settings;\n    stringBuffer;\n    byteBuffer;\n    buffer;\n    constructor(settings) {\n        super();\n        this.settings = settings;\n    }\n    write(schema, value) {\n        const ns = NormalizedSchema.of(schema);\n        if (ns.isStringSchema() && typeof value === \"string\") {\n            this.stringBuffer = value;\n        }\n        else if (ns.isBlobSchema()) {\n            this.byteBuffer =\n                \"byteLength\" in value\n                    ? value\n                    : (this.serdeContext?.base64Decoder ?? fromBase64)(value);\n        }\n        else {\n            this.buffer = this.writeStruct(ns, value, undefined);\n            const traits = ns.getMergedTraits();\n            if (traits.httpPayload && !traits.xmlName) {\n                this.buffer.withName(ns.getName());\n            }\n        }\n    }\n    flush() {\n        if (this.byteBuffer !== undefined) {\n            const bytes = this.byteBuffer;\n            delete this.byteBuffer;\n            return bytes;\n        }\n        if (this.stringBuffer !== undefined) {\n            const str = this.stringBuffer;\n            delete this.stringBuffer;\n            return str;\n        }\n        const buffer = this.buffer;\n        if (this.settings.xmlNamespace) {\n            if (!buffer?.attributes?.[\"xmlns\"]) {\n                buffer.addAttribute(\"xmlns\", this.settings.xmlNamespace);\n            }\n        }\n        delete this.buffer;\n        return buffer.toString();\n    }\n    writeStruct(ns, value, parentXmlns) {\n        const traits = ns.getMergedTraits();\n        const name = ns.isMemberSchema() && !traits.httpPayload\n            ? ns.getMemberTraits().xmlName ?? ns.getMemberName()\n            : traits.xmlName ?? ns.getName();\n        if (!name || !ns.isStructSchema()) {\n            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${ns.getName(true)}.`);\n        }\n        const structXmlNode = XmlNode.of(name);\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n        if (xmlns) {\n            structXmlNode.addAttribute(xmlnsAttr, xmlns);\n        }\n        for (const [memberName, memberSchema] of ns.structIterator()) {\n            const val = value[memberName];\n            if (val != null || memberSchema.isIdempotencyToken()) {\n                if (memberSchema.getMergedTraits().xmlAttribute) {\n                    structXmlNode.addAttribute(memberSchema.getMergedTraits().xmlName ?? memberName, this.writeSimple(memberSchema, val));\n                    continue;\n                }\n                if (memberSchema.isListSchema()) {\n                    this.writeList(memberSchema, val, structXmlNode, xmlns);\n                }\n                else if (memberSchema.isMapSchema()) {\n                    this.writeMap(memberSchema, val, structXmlNode, xmlns);\n                }\n                else if (memberSchema.isStructSchema()) {\n                    structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));\n                }\n                else {\n                    const memberNode = XmlNode.of(memberSchema.getMergedTraits().xmlName ?? memberSchema.getMemberName());\n                    this.writeSimpleInto(memberSchema, val, memberNode, xmlns);\n                    structXmlNode.addChildNode(memberNode);\n                }\n            }\n        }\n        return structXmlNode;\n    }\n    writeList(listMember, array, container, parentXmlns) {\n        if (!listMember.isMemberSchema()) {\n            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${listMember.getName(true)}`);\n        }\n        const listTraits = listMember.getMergedTraits();\n        const listValueSchema = listMember.getValueSchema();\n        const listValueTraits = listValueSchema.getMergedTraits();\n        const sparse = !!listValueTraits.sparse;\n        const flat = !!listTraits.xmlFlattened;\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);\n        const writeItem = (container, value) => {\n            if (listValueSchema.isListSchema()) {\n                this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container, xmlns);\n            }\n            else if (listValueSchema.isMapSchema()) {\n                this.writeMap(listValueSchema, value, container, xmlns);\n            }\n            else if (listValueSchema.isStructSchema()) {\n                const struct = this.writeStruct(listValueSchema, value, xmlns);\n                container.addChildNode(struct.withName(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? \"member\"));\n            }\n            else {\n                const listItemNode = XmlNode.of(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? \"member\");\n                this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);\n                container.addChildNode(listItemNode);\n            }\n        };\n        if (flat) {\n            for (const value of array) {\n                if (sparse || value != null) {\n                    writeItem(container, value);\n                }\n            }\n        }\n        else {\n            const listNode = XmlNode.of(listTraits.xmlName ?? listMember.getMemberName());\n            if (xmlns) {\n                listNode.addAttribute(xmlnsAttr, xmlns);\n            }\n            for (const value of array) {\n                if (sparse || value != null) {\n                    writeItem(listNode, value);\n                }\n            }\n            container.addChildNode(listNode);\n        }\n    }\n    writeMap(mapMember, map, container, parentXmlns, containerIsMap = false) {\n        if (!mapMember.isMemberSchema()) {\n            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${mapMember.getName(true)}`);\n        }\n        const mapTraits = mapMember.getMergedTraits();\n        const mapKeySchema = mapMember.getKeySchema();\n        const mapKeyTraits = mapKeySchema.getMergedTraits();\n        const keyTag = mapKeyTraits.xmlName ?? \"key\";\n        const mapValueSchema = mapMember.getValueSchema();\n        const mapValueTraits = mapValueSchema.getMergedTraits();\n        const valueTag = mapValueTraits.xmlName ?? \"value\";\n        const sparse = !!mapValueTraits.sparse;\n        const flat = !!mapTraits.xmlFlattened;\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);\n        const addKeyValue = (entry, key, val) => {\n            const keyNode = XmlNode.of(keyTag, key);\n            const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);\n            if (keyXmlns) {\n                keyNode.addAttribute(keyXmlnsAttr, keyXmlns);\n            }\n            entry.addChildNode(keyNode);\n            let valueNode = XmlNode.of(valueTag);\n            if (mapValueSchema.isListSchema()) {\n                this.writeList(mapValueSchema, val, valueNode, xmlns);\n            }\n            else if (mapValueSchema.isMapSchema()) {\n                this.writeMap(mapValueSchema, val, valueNode, xmlns, true);\n            }\n            else if (mapValueSchema.isStructSchema()) {\n                valueNode = this.writeStruct(mapValueSchema, val, xmlns);\n            }\n            else {\n                this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);\n            }\n            entry.addChildNode(valueNode);\n        };\n        if (flat) {\n            for (const [key, val] of Object.entries(map)) {\n                if (sparse || val != null) {\n                    const entry = XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());\n                    addKeyValue(entry, key, val);\n                    container.addChildNode(entry);\n                }\n            }\n        }\n        else {\n            let mapNode;\n            if (!containerIsMap) {\n                mapNode = XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());\n                if (xmlns) {\n                    mapNode.addAttribute(xmlnsAttr, xmlns);\n                }\n                container.addChildNode(mapNode);\n            }\n            for (const [key, val] of Object.entries(map)) {\n                if (sparse || val != null) {\n                    const entry = XmlNode.of(\"entry\");\n                    addKeyValue(entry, key, val);\n                    (containerIsMap ? container : mapNode).addChildNode(entry);\n                }\n            }\n        }\n    }\n    writeSimple(_schema, value) {\n        if (null === value) {\n            throw new Error(\"@aws-sdk/core/protocols - (XML serializer) cannot write null value.\");\n        }\n        const ns = NormalizedSchema.of(_schema);\n        let nodeContents = null;\n        if (value && typeof value === \"object\") {\n            if (ns.isBlobSchema()) {\n                nodeContents = (this.serdeContext?.base64Encoder ?? toBase64)(value);\n            }\n            else if (ns.isTimestampSchema() && value instanceof Date) {\n                const options = this.settings.timestampFormat;\n                const format = options.useTrait\n                    ? ns.getSchema() === SCHEMA.TIMESTAMP_DEFAULT\n                        ? options.default\n                        : ns.getSchema() ?? options.default\n                    : options.default;\n                switch (format) {\n                    case SCHEMA.TIMESTAMP_DATE_TIME:\n                        nodeContents = value.toISOString().replace(\".000Z\", \"Z\");\n                        break;\n                    case SCHEMA.TIMESTAMP_HTTP_DATE:\n                        nodeContents = dateToUtcString(value);\n                        break;\n                    case SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n                        nodeContents = String(value.getTime() / 1000);\n                        break;\n                    default:\n                        console.warn(\"Missing timestamp format, using http date\", value);\n                        nodeContents = dateToUtcString(value);\n                        break;\n                }\n            }\n            else if (ns.isBigDecimalSchema() && value) {\n                if (value instanceof NumericValue) {\n                    return value.string;\n                }\n                return String(value);\n            }\n            else if (ns.isMapSchema() || ns.isListSchema()) {\n                throw new Error(\"@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.\");\n            }\n            else {\n                throw new Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${ns.getName(true)}`);\n            }\n        }\n        if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isBigIntegerSchema() || ns.isBigDecimalSchema()) {\n            nodeContents = String(value);\n        }\n        if (ns.isStringSchema()) {\n            if (value === undefined && ns.isIdempotencyToken()) {\n                nodeContents = generateIdempotencyToken();\n            }\n            else {\n                nodeContents = String(value);\n            }\n        }\n        if (nodeContents === null) {\n            throw new Error(`Unhandled schema-value pair ${ns.getName(true)}=${value}`);\n        }\n        return nodeContents;\n    }\n    writeSimpleInto(_schema, value, into, parentXmlns) {\n        const nodeContents = this.writeSimple(_schema, value);\n        const ns = NormalizedSchema.of(_schema);\n        const content = new XmlText(nodeContents);\n        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);\n        if (xmlns) {\n            into.addAttribute(xmlnsAttr, xmlns);\n        }\n        into.addChildNode(content);\n    }\n    getXmlnsAttribute(ns, parentXmlns) {\n        const traits = ns.getMergedTraits();\n        const [prefix, xmlns] = traits.xmlNamespace ?? [];\n        if (xmlns && xmlns !== parentXmlns) {\n            return [prefix ? `xmlns:${prefix}` : \"xmlns\", xmlns];\n        }\n        return [void 0, void 0];\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}