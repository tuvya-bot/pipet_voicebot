{"ast":null,"code":"import { isName } from '../util.js';\n\n//TODO: handle comments\nexport default function readDocType(xmlData, i) {\n  const entities = {};\n  if (xmlData[i + 3] === 'O' && xmlData[i + 4] === 'C' && xmlData[i + 5] === 'T' && xmlData[i + 6] === 'Y' && xmlData[i + 7] === 'P' && xmlData[i + 8] === 'E') {\n    i = i + 9;\n    let angleBracketsCount = 1;\n    let hasBody = false,\n      comment = false;\n    let exp = \"\";\n    for (; i < xmlData.length; i++) {\n      if (xmlData[i] === '<' && !comment) {\n        //Determine the tag type\n        if (hasBody && hasSeq(xmlData, \"!ENTITY\", i)) {\n          i += 7;\n          let entityName, val;\n          [entityName, val, i] = readEntityExp(xmlData, i + 1);\n          if (val.indexOf(\"&\") === -1)\n            //Parameter entities are not supported\n            entities[entityName] = {\n              regx: RegExp(`&${entityName};`, \"g\"),\n              val: val\n            };\n        } else if (hasBody && hasSeq(xmlData, \"!ELEMENT\", i)) {\n          i += 8; //Not supported\n          const {\n            index\n          } = readElementExp(xmlData, i + 1);\n          i = index;\n        } else if (hasBody && hasSeq(xmlData, \"!ATTLIST\", i)) {\n          i += 8; //Not supported\n          // const {index} = readAttlistExp(xmlData,i+1);\n          // i = index;\n        } else if (hasBody && hasSeq(xmlData, \"!NOTATION\", i)) {\n          i += 9; //Not supported\n          const {\n            index\n          } = readNotationExp(xmlData, i + 1);\n          i = index;\n        } else if (hasSeq(xmlData, \"!--\", i)) comment = true;else throw new Error(`Invalid DOCTYPE`);\n        angleBracketsCount++;\n        exp = \"\";\n      } else if (xmlData[i] === '>') {\n        //Read tag content\n        if (comment) {\n          if (xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\") {\n            comment = false;\n            angleBracketsCount--;\n          }\n        } else {\n          angleBracketsCount--;\n        }\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      } else if (xmlData[i] === '[') {\n        hasBody = true;\n      } else {\n        exp += xmlData[i];\n      }\n    }\n    if (angleBracketsCount !== 0) {\n      throw new Error(`Unclosed DOCTYPE`);\n    }\n  } else {\n    throw new Error(`Invalid Tag instead of DOCTYPE`);\n  }\n  return {\n    entities,\n    i\n  };\n}\nconst skipWhitespace = (data, index) => {\n  while (index < data.length && /\\s/.test(data[index])) {\n    index++;\n  }\n  return index;\n};\nfunction readEntityExp(xmlData, i) {\n  //External entities are not supported\n  //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n  //Parameter entities are not supported\n  //    <!ENTITY entityname \"&anotherElement;\">\n\n  //Internal entities are supported\n  //    <!ENTITY entityname \"replacement text\">\n\n  // Skip leading whitespace after <!ENTITY\n  i = skipWhitespace(xmlData, i);\n\n  // Read entity name\n  let entityName = \"\";\n  while (i < xmlData.length && !/\\s/.test(xmlData[i]) && xmlData[i] !== '\"' && xmlData[i] !== \"'\") {\n    entityName += xmlData[i];\n    i++;\n  }\n  validateEntityName(entityName);\n\n  // Skip whitespace after entity name\n  i = skipWhitespace(xmlData, i);\n\n  // Check for unsupported constructs (external entities or parameter entities)\n  if (xmlData.substring(i, i + 6).toUpperCase() === \"SYSTEM\") {\n    throw new Error(\"External entities are not supported\");\n  } else if (xmlData[i] === \"%\") {\n    throw new Error(\"Parameter entities are not supported\");\n  }\n\n  // Read entity value (internal entity)\n  let entityValue = \"\";\n  [i, entityValue] = readIdentifierVal(xmlData, i, \"entity\");\n  i--;\n  return [entityName, entityValue, i];\n}\nfunction readNotationExp(xmlData, i) {\n  // Skip leading whitespace after <!NOTATION\n  i = skipWhitespace(xmlData, i);\n\n  // Read notation name\n  let notationName = \"\";\n  while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n    notationName += xmlData[i];\n    i++;\n  }\n  validateEntityName(notationName);\n\n  // Skip whitespace after notation name\n  i = skipWhitespace(xmlData, i);\n\n  // Check identifier type (SYSTEM or PUBLIC)\n  const identifierType = xmlData.substring(i, i + 6).toUpperCase();\n  if (identifierType !== \"SYSTEM\" && identifierType !== \"PUBLIC\") {\n    throw new Error(`Expected SYSTEM or PUBLIC, found \"${identifierType}\"`);\n  }\n  i += identifierType.length;\n\n  // Skip whitespace after identifier type\n  i = skipWhitespace(xmlData, i);\n\n  // Read public identifier (if PUBLIC)\n  let publicIdentifier = null;\n  let systemIdentifier = null;\n  if (identifierType === \"PUBLIC\") {\n    [i, publicIdentifier] = readIdentifierVal(xmlData, i, \"publicIdentifier\");\n\n    // Skip whitespace after public identifier\n    i = skipWhitespace(xmlData, i);\n\n    // Optionally read system identifier\n    if (xmlData[i] === '\"' || xmlData[i] === \"'\") {\n      [i, systemIdentifier] = readIdentifierVal(xmlData, i, \"systemIdentifier\");\n    }\n  } else if (identifierType === \"SYSTEM\") {\n    // Read system identifier (mandatory for SYSTEM)\n    [i, systemIdentifier] = readIdentifierVal(xmlData, i, \"systemIdentifier\");\n    if (!systemIdentifier) {\n      throw new Error(\"Missing mandatory system identifier for SYSTEM notation\");\n    }\n  }\n  return {\n    notationName,\n    publicIdentifier,\n    systemIdentifier,\n    index: --i\n  };\n}\nfunction readIdentifierVal(xmlData, i, type) {\n  let identifierVal = \"\";\n  const startChar = xmlData[i];\n  if (startChar !== '\"' && startChar !== \"'\") {\n    throw new Error(`Expected quoted string, found \"${startChar}\"`);\n  }\n  i++;\n  while (i < xmlData.length && xmlData[i] !== startChar) {\n    identifierVal += xmlData[i];\n    i++;\n  }\n  if (xmlData[i] !== startChar) {\n    throw new Error(`Unterminated ${type} value`);\n  }\n  i++;\n  return [i, identifierVal];\n}\nfunction readElementExp(xmlData, i) {\n  // <!ELEMENT br EMPTY>\n  // <!ELEMENT div ANY>\n  // <!ELEMENT title (#PCDATA)>\n  // <!ELEMENT book (title, author+)>\n  // <!ELEMENT name (content-model)>\n\n  // Skip leading whitespace after <!ELEMENT\n  i = skipWhitespace(xmlData, i);\n\n  // Read element name\n  let elementName = \"\";\n  while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n    elementName += xmlData[i];\n    i++;\n  }\n\n  // Validate element name\n  if (!validateEntityName(elementName)) {\n    throw new Error(`Invalid element name: \"${elementName}\"`);\n  }\n\n  // Skip whitespace after element name\n  i = skipWhitespace(xmlData, i);\n  let contentModel = \"\";\n  // Expect '(' to start content model\n  if (xmlData[i] === \"E\" && hasSeq(xmlData, \"MPTY\", i)) i += 4;else if (xmlData[i] === \"A\" && hasSeq(xmlData, \"NY\", i)) i += 2;else if (xmlData[i] === \"(\") {\n    i++; // Move past '('\n\n    // Read content model\n    while (i < xmlData.length && xmlData[i] !== \")\") {\n      contentModel += xmlData[i];\n      i++;\n    }\n    if (xmlData[i] !== \")\") {\n      throw new Error(\"Unterminated content model\");\n    }\n  } else {\n    throw new Error(`Invalid Element Expression, found \"${xmlData[i]}\"`);\n  }\n  return {\n    elementName,\n    contentModel: contentModel.trim(),\n    index: i\n  };\n}\nfunction readAttlistExp(xmlData, i) {\n  // Skip leading whitespace after <!ATTLIST\n  i = skipWhitespace(xmlData, i);\n\n  // Read element name\n  let elementName = \"\";\n  while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n    elementName += xmlData[i];\n    i++;\n  }\n\n  // Validate element name\n  validateEntityName(elementName);\n\n  // Skip whitespace after element name\n  i = skipWhitespace(xmlData, i);\n\n  // Read attribute name\n  let attributeName = \"\";\n  while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n    attributeName += xmlData[i];\n    i++;\n  }\n\n  // Validate attribute name\n  if (!validateEntityName(attributeName)) {\n    throw new Error(`Invalid attribute name: \"${attributeName}\"`);\n  }\n\n  // Skip whitespace after attribute name\n  i = skipWhitespace(xmlData, i);\n\n  // Read attribute type\n  let attributeType = \"\";\n  if (xmlData.substring(i, i + 8).toUpperCase() === \"NOTATION\") {\n    attributeType = \"NOTATION\";\n    i += 8; // Move past \"NOTATION\"\n\n    // Skip whitespace after \"NOTATION\"\n    i = skipWhitespace(xmlData, i);\n\n    // Expect '(' to start the list of notations\n    if (xmlData[i] !== \"(\") {\n      throw new Error(`Expected '(', found \"${xmlData[i]}\"`);\n    }\n    i++; // Move past '('\n\n    // Read the list of allowed notations\n    let allowedNotations = [];\n    while (i < xmlData.length && xmlData[i] !== \")\") {\n      let notation = \"\";\n      while (i < xmlData.length && xmlData[i] !== \"|\" && xmlData[i] !== \")\") {\n        notation += xmlData[i];\n        i++;\n      }\n\n      // Validate notation name\n      notation = notation.trim();\n      if (!validateEntityName(notation)) {\n        throw new Error(`Invalid notation name: \"${notation}\"`);\n      }\n      allowedNotations.push(notation);\n\n      // Skip '|' separator or exit loop\n      if (xmlData[i] === \"|\") {\n        i++; // Move past '|'\n        i = skipWhitespace(xmlData, i); // Skip optional whitespace after '|'\n      }\n    }\n    if (xmlData[i] !== \")\") {\n      throw new Error(\"Unterminated list of notations\");\n    }\n    i++; // Move past ')'\n\n    // Store the allowed notations as part of the attribute type\n    attributeType += \" (\" + allowedNotations.join(\"|\") + \")\";\n  } else {\n    // Handle simple types (e.g., CDATA, ID, IDREF, etc.)\n    while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n      attributeType += xmlData[i];\n      i++;\n    }\n\n    // Validate simple attribute type\n    const validTypes = [\"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"ENTITY\", \"ENTITIES\", \"NMTOKEN\", \"NMTOKENS\"];\n    if (!validTypes.includes(attributeType.toUpperCase())) {\n      throw new Error(`Invalid attribute type: \"${attributeType}\"`);\n    }\n  }\n\n  // Skip whitespace after attribute type\n  i = skipWhitespace(xmlData, i);\n\n  // Read default value\n  let defaultValue = \"\";\n  if (xmlData.substring(i, i + 8).toUpperCase() === \"#REQUIRED\") {\n    defaultValue = \"#REQUIRED\";\n    i += 8;\n  } else if (xmlData.substring(i, i + 7).toUpperCase() === \"#IMPLIED\") {\n    defaultValue = \"#IMPLIED\";\n    i += 7;\n  } else {\n    [i, defaultValue] = readIdentifierVal(xmlData, i, \"ATTLIST\");\n  }\n  return {\n    elementName,\n    attributeName,\n    attributeType,\n    defaultValue,\n    index: i\n  };\n}\nfunction hasSeq(data, seq, i) {\n  for (let j = 0; j < seq.length; j++) {\n    if (seq[j] !== data[i + j + 1]) return false;\n  }\n  return true;\n}\nfunction validateEntityName(name) {\n  if (isName(name)) return name;else throw new Error(`Invalid entity name ${name}`);\n}","map":{"version":3,"names":["isName","readDocType","xmlData","i","entities","angleBracketsCount","hasBody","comment","exp","length","hasSeq","entityName","val","readEntityExp","indexOf","regx","RegExp","index","readElementExp","readNotationExp","Error","skipWhitespace","data","test","validateEntityName","substring","toUpperCase","entityValue","readIdentifierVal","notationName","identifierType","publicIdentifier","systemIdentifier","type","identifierVal","startChar","elementName","contentModel","trim","readAttlistExp","attributeName","attributeType","allowedNotations","notation","push","join","validTypes","includes","defaultValue","seq","j","name"],"sources":["/Users/tuvyakhatter/Desktop/pipecat_voicebot/~/Desktop/sow_editor/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"],"sourcesContent":["import {isName} from '../util.js';\n\n//TODO: handle comments\nexport default function readDocType(xmlData, i){\n    \n    const entities = {};\n    if( xmlData[i + 3] === 'O' &&\n         xmlData[i + 4] === 'C' &&\n         xmlData[i + 5] === 'T' &&\n         xmlData[i + 6] === 'Y' &&\n         xmlData[i + 7] === 'P' &&\n         xmlData[i + 8] === 'E')\n    {    \n        i = i+9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(;i<xmlData.length;i++){\n            if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                if( hasBody && hasSeq(xmlData, \"!ENTITY\",i)){\n                    i += 7; \n                    let entityName, val;\n                    [entityName, val,i] = readEntityExp(xmlData,i+1);\n                    if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                        entities[ entityName ] = {\n                            regx : RegExp( `&${entityName};`,\"g\"),\n                            val: val\n                        };\n                }\n                else if( hasBody && hasSeq(xmlData, \"!ELEMENT\",i))  {\n                    i += 8;//Not supported\n                    const {index} = readElementExp(xmlData,i+1);\n                    i = index;\n                }else if( hasBody && hasSeq(xmlData, \"!ATTLIST\",i)){\n                    i += 8;//Not supported\n                    // const {index} = readAttlistExp(xmlData,i+1);\n                    // i = index;\n                }else if( hasBody && hasSeq(xmlData, \"!NOTATION\",i)) {\n                    i += 9;//Not supported\n                    const {index} = readNotationExp(xmlData,i+1);\n                    i = index;\n                }else if( hasSeq(xmlData, \"!--\",i) ) comment = true;\n                else throw new Error(`Invalid DOCTYPE`);\n\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === '>') { //Read tag content\n                if(comment){\n                    if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                }else{\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                  break;\n                }\n            }else if( xmlData[i] === '['){\n                hasBody = true;\n            }else{\n                exp += xmlData[i];\n            }\n        }\n        if(angleBracketsCount !== 0){\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    }else{\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {entities, i};\n}\n\nconst skipWhitespace = (data, index) => {\n    while (index < data.length && /\\s/.test(data[index])) {\n        index++;\n    }\n    return index;\n};\n\nfunction readEntityExp(xmlData, i) {    \n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n\n    // Skip leading whitespace after <!ENTITY\n    i = skipWhitespace(xmlData, i);\n\n    // Read entity name\n    let entityName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i]) && xmlData[i] !== '\"' && xmlData[i] !== \"'\") {\n        entityName += xmlData[i];\n        i++;\n    }\n    validateEntityName(entityName);\n\n    // Skip whitespace after entity name\n    i = skipWhitespace(xmlData, i);\n\n    // Check for unsupported constructs (external entities or parameter entities)\n    if (xmlData.substring(i, i + 6).toUpperCase() === \"SYSTEM\") {\n        throw new Error(\"External entities are not supported\");\n    }else if (xmlData[i] === \"%\") {\n        throw new Error(\"Parameter entities are not supported\");\n    }\n\n    // Read entity value (internal entity)\n    let entityValue = \"\";\n    [i, entityValue] = readIdentifierVal(xmlData, i, \"entity\");\n    i--;\n    return [entityName, entityValue, i ];\n}\n\nfunction readNotationExp(xmlData, i) {\n    // Skip leading whitespace after <!NOTATION\n    i = skipWhitespace(xmlData, i);\n\n    // Read notation name\n    let notationName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n        notationName += xmlData[i];\n        i++;\n    }\n    validateEntityName(notationName);\n\n    // Skip whitespace after notation name\n    i = skipWhitespace(xmlData, i);\n\n    // Check identifier type (SYSTEM or PUBLIC)\n    const identifierType = xmlData.substring(i, i + 6).toUpperCase();\n    if (identifierType !== \"SYSTEM\" && identifierType !== \"PUBLIC\") {\n        throw new Error(`Expected SYSTEM or PUBLIC, found \"${identifierType}\"`);\n    }\n    i += identifierType.length;\n\n    // Skip whitespace after identifier type\n    i = skipWhitespace(xmlData, i);\n\n    // Read public identifier (if PUBLIC)\n    let publicIdentifier = null;\n    let systemIdentifier = null;\n\n    if (identifierType === \"PUBLIC\") {\n        [i, publicIdentifier ] = readIdentifierVal(xmlData, i, \"publicIdentifier\");\n\n        // Skip whitespace after public identifier\n        i = skipWhitespace(xmlData, i);\n\n        // Optionally read system identifier\n        if (xmlData[i] === '\"' || xmlData[i] === \"'\") {\n            [i, systemIdentifier ] = readIdentifierVal(xmlData, i,\"systemIdentifier\");\n        }\n    } else if (identifierType === \"SYSTEM\") {\n        // Read system identifier (mandatory for SYSTEM)\n        [i, systemIdentifier ] = readIdentifierVal(xmlData, i, \"systemIdentifier\");\n\n        if (!systemIdentifier) {\n            throw new Error(\"Missing mandatory system identifier for SYSTEM notation\");\n        }\n    }\n    \n    return {notationName, publicIdentifier, systemIdentifier, index: --i};\n}\n\nfunction readIdentifierVal(xmlData, i, type) {\n    let identifierVal = \"\";\n    const startChar = xmlData[i];\n    if (startChar !== '\"' && startChar !== \"'\") {\n        throw new Error(`Expected quoted string, found \"${startChar}\"`);\n    }\n    i++;\n\n    while (i < xmlData.length && xmlData[i] !== startChar) {\n        identifierVal += xmlData[i];\n        i++;\n    }\n\n    if (xmlData[i] !== startChar) {\n        throw new Error(`Unterminated ${type} value`);\n    }\n    i++;\n    return [i, identifierVal];\n}\n\nfunction readElementExp(xmlData, i) {\n    // <!ELEMENT br EMPTY>\n    // <!ELEMENT div ANY>\n    // <!ELEMENT title (#PCDATA)>\n    // <!ELEMENT book (title, author+)>\n    // <!ELEMENT name (content-model)>\n    \n    // Skip leading whitespace after <!ELEMENT\n    i = skipWhitespace(xmlData, i);\n\n    // Read element name\n    let elementName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n        elementName += xmlData[i];\n        i++;\n    }\n\n    // Validate element name\n    if (!validateEntityName(elementName)) {\n        throw new Error(`Invalid element name: \"${elementName}\"`);\n    }\n\n    // Skip whitespace after element name\n    i = skipWhitespace(xmlData, i);\n    let contentModel = \"\";\n    // Expect '(' to start content model\n    if(xmlData[i] === \"E\" && hasSeq(xmlData, \"MPTY\",i)) i+=4;\n    else if(xmlData[i] === \"A\" && hasSeq(xmlData, \"NY\",i)) i+=2;\n    else if (xmlData[i] === \"(\") {\n        i++; // Move past '('\n\n        // Read content model\n        while (i < xmlData.length && xmlData[i] !== \")\") {\n            contentModel += xmlData[i];\n            i++;\n        }\n        if (xmlData[i] !== \")\") {\n            throw new Error(\"Unterminated content model\");\n        }\n\n    }else{\n        throw new Error(`Invalid Element Expression, found \"${xmlData[i]}\"`);\n    }\n    \n    return {\n        elementName,\n        contentModel: contentModel.trim(),\n        index: i\n    };\n}\n\nfunction readAttlistExp(xmlData, i) {\n    // Skip leading whitespace after <!ATTLIST\n    i = skipWhitespace(xmlData, i);\n\n    // Read element name\n    let elementName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n        elementName += xmlData[i];\n        i++;\n    }\n\n    // Validate element name\n    validateEntityName(elementName)\n\n    // Skip whitespace after element name\n    i = skipWhitespace(xmlData, i);\n\n    // Read attribute name\n    let attributeName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n        attributeName += xmlData[i];\n        i++;\n    }\n\n    // Validate attribute name\n    if (!validateEntityName(attributeName)) {\n        throw new Error(`Invalid attribute name: \"${attributeName}\"`);\n    }\n\n    // Skip whitespace after attribute name\n    i = skipWhitespace(xmlData, i);\n\n    // Read attribute type\n    let attributeType = \"\";\n    if (xmlData.substring(i, i + 8).toUpperCase() === \"NOTATION\") {\n        attributeType = \"NOTATION\";\n        i += 8; // Move past \"NOTATION\"\n\n        // Skip whitespace after \"NOTATION\"\n        i = skipWhitespace(xmlData, i);\n\n        // Expect '(' to start the list of notations\n        if (xmlData[i] !== \"(\") {\n            throw new Error(`Expected '(', found \"${xmlData[i]}\"`);\n        }\n        i++; // Move past '('\n\n        // Read the list of allowed notations\n        let allowedNotations = [];\n        while (i < xmlData.length && xmlData[i] !== \")\") {\n            let notation = \"\";\n            while (i < xmlData.length && xmlData[i] !== \"|\" && xmlData[i] !== \")\") {\n                notation += xmlData[i];\n                i++;\n            }\n\n            // Validate notation name\n            notation = notation.trim();\n            if (!validateEntityName(notation)) {\n                throw new Error(`Invalid notation name: \"${notation}\"`);\n            }\n\n            allowedNotations.push(notation);\n\n            // Skip '|' separator or exit loop\n            if (xmlData[i] === \"|\") {\n                i++; // Move past '|'\n                i = skipWhitespace(xmlData, i); // Skip optional whitespace after '|'\n            }\n        }\n\n        if (xmlData[i] !== \")\") {\n            throw new Error(\"Unterminated list of notations\");\n        }\n        i++; // Move past ')'\n\n        // Store the allowed notations as part of the attribute type\n        attributeType += \" (\" + allowedNotations.join(\"|\") + \")\";\n    } else {\n        // Handle simple types (e.g., CDATA, ID, IDREF, etc.)\n        while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n            attributeType += xmlData[i];\n            i++;\n        }\n\n        // Validate simple attribute type\n        const validTypes = [\"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"ENTITY\", \"ENTITIES\", \"NMTOKEN\", \"NMTOKENS\"];\n        if (!validTypes.includes(attributeType.toUpperCase())) {\n            throw new Error(`Invalid attribute type: \"${attributeType}\"`);\n        }\n    }\n\n    // Skip whitespace after attribute type\n    i = skipWhitespace(xmlData, i);\n\n    // Read default value\n    let defaultValue = \"\";\n    if (xmlData.substring(i, i + 8).toUpperCase() === \"#REQUIRED\") {\n        defaultValue = \"#REQUIRED\";\n        i += 8;\n    } else if (xmlData.substring(i, i + 7).toUpperCase() === \"#IMPLIED\") {\n        defaultValue = \"#IMPLIED\";\n        i += 7;\n    } else {\n        [i, defaultValue] = readIdentifierVal(xmlData, i, \"ATTLIST\");\n    }\n\n    return {\n        elementName,\n        attributeName,\n        attributeType,\n        defaultValue,\n        index: i\n    }\n}\n\nfunction hasSeq(data, seq,i){\n    for(let j=0;j<seq.length;j++){\n        if(seq[j]!==data[i+j+1]) return false;\n    }\n    return true;\n}\n\nfunction validateEntityName(name){\n    if (isName(name))\n\treturn name;\n    else\n        throw new Error(`Invalid entity name ${name}`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}