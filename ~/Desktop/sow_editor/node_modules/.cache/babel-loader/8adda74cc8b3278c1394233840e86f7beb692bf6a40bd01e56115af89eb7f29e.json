{"ast":null,"code":"const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)([0-9]*(\\.[0-9]*)?)$/;\n// const octRegex = /^0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\nconst consider = {\n  hex: true,\n  // oct: false,\n  leadingZeros: true,\n  decimalPoint: \"\\.\",\n  eNotation: true\n  //skipLike: /regex/\n};\nexport default function toNumber(str, options = {}) {\n  options = Object.assign({}, consider, options);\n  if (!str || typeof str !== \"string\") return str;\n  let trimmedStr = str.trim();\n  if (options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;else if (str === \"0\") return 0;else if (options.hex && hexRegex.test(trimmedStr)) {\n    return parse_int(trimmedStr, 16);\n    // }else if (options.oct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n  } else if (trimmedStr.search(/.+[eE].+/) !== -1) {\n    //eNotation\n    return resolveEnotation(str, trimmedStr, options);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n  } else {\n    //separate negative sign, leading zeros, and rest number\n    const match = numRegex.exec(trimmedStr);\n    // +00.123 => [ , '+', '00', '.123', ..\n    if (match) {\n      const sign = match[1] || \"\";\n      const leadingZeros = match[2];\n      let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n      const decimalAdjacentToLeadingZeros = sign ?\n      // 0., -00., 000.\n      str[leadingZeros.length + 1] === \".\" : str[leadingZeros.length] === \".\";\n\n      //trim ending zeros for floating number\n      if (!options.leadingZeros //leading zeros are not allowed\n      && (leadingZeros.length > 1 || leadingZeros.length === 1 && !decimalAdjacentToLeadingZeros)) {\n        // 00, 00.3, +03.24, 03, 03.24\n        return str;\n      } else {\n        //no leading zeros or leading zeros are allowed\n        const num = Number(trimmedStr);\n        const parsedStr = String(num);\n        if (num === 0) return num;\n        if (parsedStr.search(/[eE]/) !== -1) {\n          //given number is long and parsed to eNotation\n          if (options.eNotation) return num;else return str;\n        } else if (trimmedStr.indexOf(\".\") !== -1) {\n          //floating number\n          if (parsedStr === \"0\") return num; //0.0\n          else if (parsedStr === numTrimmedByZeros) return num; //0.456. 0.79000\n          else if (parsedStr === `${sign}${numTrimmedByZeros}`) return num;else return str;\n        }\n        let n = leadingZeros ? numTrimmedByZeros : trimmedStr;\n        if (leadingZeros) {\n          // -009 => -9\n          return n === parsedStr || sign + n === parsedStr ? num : str;\n        } else {\n          // +9\n          return n === parsedStr || n === sign + parsedStr ? num : str;\n        }\n      }\n    } else {\n      //non-numeric string\n      return str;\n    }\n  }\n}\nconst eNotationRegx = /^([-+])?(0*)(\\d*(\\.\\d*)?[eE][-\\+]?\\d+)$/;\nfunction resolveEnotation(str, trimmedStr, options) {\n  if (!options.eNotation) return str;\n  const notation = trimmedStr.match(eNotationRegx);\n  if (notation) {\n    let sign = notation[1] || \"\";\n    const eChar = notation[3].indexOf(\"e\") === -1 ? \"E\" : \"e\";\n    const leadingZeros = notation[2];\n    const eAdjacentToLeadingZeros = sign ?\n    // 0E.\n    str[leadingZeros.length + 1] === eChar : str[leadingZeros.length] === eChar;\n    if (leadingZeros.length > 1 && eAdjacentToLeadingZeros) return str;else if (leadingZeros.length === 1 && (notation[3].startsWith(`.${eChar}`) || notation[3][0] === eChar)) {\n      return Number(trimmedStr);\n    } else if (options.leadingZeros && !eAdjacentToLeadingZeros) {\n      //accept with leading zeros\n      //remove leading 0s\n      trimmedStr = (notation[1] || \"\") + notation[3];\n      return Number(trimmedStr);\n    } else return str;\n  } else {\n    return str;\n  }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr) {\n  if (numStr && numStr.indexOf(\".\") !== -1) {\n    //float\n    numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n    if (numStr === \".\") numStr = \"0\";else if (numStr[0] === \".\") numStr = \"0\" + numStr;else if (numStr[numStr.length - 1] === \".\") numStr = numStr.substring(0, numStr.length - 1);\n    return numStr;\n  }\n  return numStr;\n}\nfunction parse_int(numStr, base) {\n  //polyfill\n  if (parseInt) return parseInt(numStr, base);else if (Number.parseInt) return Number.parseInt(numStr, base);else if (window && window.parseInt) return window.parseInt(numStr, base);else throw new Error(\"parseInt, Number.parseInt, window.parseInt are not supported\");\n}","map":{"version":3,"names":["hexRegex","numRegex","consider","hex","leadingZeros","decimalPoint","eNotation","toNumber","str","options","Object","assign","trimmedStr","trim","skipLike","undefined","test","parse_int","search","resolveEnotation","match","exec","sign","numTrimmedByZeros","trimZeros","decimalAdjacentToLeadingZeros","length","num","Number","parsedStr","String","indexOf","n","eNotationRegx","notation","eChar","eAdjacentToLeadingZeros","startsWith","numStr","replace","substring","base","parseInt","window","Error"],"sources":["/Users/tuvyakhatter/Desktop/pipecat_voicebot/~/Desktop/sow_editor/node_modules/strnum/strnum.js"],"sourcesContent":["const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)([0-9]*(\\.[0-9]*)?)$/;\n// const octRegex = /^0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n \nconst consider = {\n    hex :  true,\n    // oct: false,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true,\n    //skipLike: /regex/\n};\n\nexport default function toNumber(str, options = {}){\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    \n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if(str===\"0\") return 0;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return parse_int(trimmedStr, 16);\n    // }else if (options.oct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    }else if (trimmedStr.search(/.+[eE].+/)!== -1) { //eNotation\n        return resolveEnotation(str,trimmedStr,options);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        // +00.123 => [ , '+', '00', '.123', ..\n        if(match){\n            const sign = match[1] || \"\";\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            const decimalAdjacentToLeadingZeros = sign ? // 0., -00., 000.\n                str[leadingZeros.length+1] === \".\" \n                : str[leadingZeros.length] === \".\";\n\n            //trim ending zeros for floating number\n            if(!options.leadingZeros //leading zeros are not allowed\n                && (leadingZeros.length > 1 \n                    || (leadingZeros.length === 1 && !decimalAdjacentToLeadingZeros))){\n                // 00, 00.3, +03.24, 03, 03.24\n                return str;\n            }\n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const parsedStr = String(num);\n\n                if( num === 0) return num;\n                if(parsedStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    if(parsedStr === \"0\") return num; //0.0\n                    else if(parsedStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( parsedStr === `${sign}${numTrimmedByZeros}`) return num;\n                    else return str;\n                }\n                \n                let n = leadingZeros? numTrimmedByZeros : trimmedStr;\n                if(leadingZeros){\n                    // -009 => -9\n                    return (n === parsedStr) || (sign+n === parsedStr) ? num : str\n                }else  {\n                    // +9\n                    return (n === parsedStr) || (n === sign+parsedStr) ? num : str\n                }\n            }\n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\nconst eNotationRegx = /^([-+])?(0*)(\\d*(\\.\\d*)?[eE][-\\+]?\\d+)$/;\nfunction resolveEnotation(str,trimmedStr,options){\n    if(!options.eNotation) return str;\n    const notation = trimmedStr.match(eNotationRegx); \n    if(notation){\n        let sign = notation[1] || \"\";\n        const eChar = notation[3].indexOf(\"e\") === -1 ? \"E\" : \"e\";\n        const leadingZeros = notation[2];\n        const eAdjacentToLeadingZeros = sign ? // 0E.\n            str[leadingZeros.length+1] === eChar \n            : str[leadingZeros.length] === eChar;\n\n        if(leadingZeros.length > 1 && eAdjacentToLeadingZeros) return str;\n        else if(leadingZeros.length === 1 \n            && (notation[3].startsWith(`.${eChar}`) || notation[3][0] === eChar)){\n                return Number(trimmedStr);\n        }else if(options.leadingZeros && !eAdjacentToLeadingZeros){ //accept with leading zeros\n            //remove leading 0s\n            trimmedStr = (notation[1] || \"\") + notation[3];\n            return Number(trimmedStr);\n        }else return str;\n    }else{\n        return str;\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substring(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\n\nfunction parse_int(numStr, base){\n    //polyfill\n    if(parseInt) return parseInt(numStr, base);\n    else if(Number.parseInt) return Number.parseInt(numStr, base);\n    else if(window && window.parseInt) return window.parseInt(numStr, base);\n    else throw new Error(\"parseInt, Number.parseInt, window.parseInt are not supported\")\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}