{"ast":null,"code":"import { ByteArrayCollector } from \"./ByteArrayCollector\";\nexport function createBufferedReadableStream(upstream, size, logger) {\n  const reader = upstream.getReader();\n  let streamBufferingLoggedWarning = false;\n  let bytesSeen = 0;\n  const buffers = [\"\", new ByteArrayCollector(size => new Uint8Array(size))];\n  let mode = -1;\n  const pull = async controller => {\n    const {\n      value,\n      done\n    } = await reader.read();\n    const chunk = value;\n    if (done) {\n      if (mode !== -1) {\n        const remainder = flush(buffers, mode);\n        if (sizeOf(remainder) > 0) {\n          controller.enqueue(remainder);\n        }\n      }\n      controller.close();\n    } else {\n      const chunkMode = modeOf(chunk, false);\n      if (mode !== chunkMode) {\n        if (mode >= 0) {\n          controller.enqueue(flush(buffers, mode));\n        }\n        mode = chunkMode;\n      }\n      if (mode === -1) {\n        controller.enqueue(chunk);\n        return;\n      }\n      const chunkSize = sizeOf(chunk);\n      bytesSeen += chunkSize;\n      const bufferSize = sizeOf(buffers[mode]);\n      if (chunkSize >= size && bufferSize === 0) {\n        controller.enqueue(chunk);\n      } else {\n        const newSize = merge(buffers, mode, chunk);\n        if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {\n          streamBufferingLoggedWarning = true;\n          logger?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);\n        }\n        if (newSize >= size) {\n          controller.enqueue(flush(buffers, mode));\n        } else {\n          await pull(controller);\n        }\n      }\n    }\n  };\n  return new ReadableStream({\n    pull\n  });\n}\nexport const createBufferedReadable = createBufferedReadableStream;\nexport function merge(buffers, mode, chunk) {\n  switch (mode) {\n    case 0:\n      buffers[0] += chunk;\n      return sizeOf(buffers[0]);\n    case 1:\n    case 2:\n      buffers[mode].push(chunk);\n      return sizeOf(buffers[mode]);\n  }\n}\nexport function flush(buffers, mode) {\n  switch (mode) {\n    case 0:\n      const s = buffers[0];\n      buffers[0] = \"\";\n      return s;\n    case 1:\n    case 2:\n      return buffers[mode].flush();\n  }\n  throw new Error(`@smithy/util-stream - invalid index ${mode} given to flush()`);\n}\nexport function sizeOf(chunk) {\n  return chunk?.byteLength ?? chunk?.length ?? 0;\n}\nexport function modeOf(chunk, allowBuffer = true) {\n  if (allowBuffer && typeof Buffer !== \"undefined\" && chunk instanceof Buffer) {\n    return 2;\n  }\n  if (chunk instanceof Uint8Array) {\n    return 1;\n  }\n  if (typeof chunk === \"string\") {\n    return 0;\n  }\n  return -1;\n}","map":{"version":3,"names":["ByteArrayCollector","createBufferedReadableStream","upstream","size","logger","reader","getReader","streamBufferingLoggedWarning","bytesSeen","buffers","Uint8Array","mode","pull","controller","value","done","read","chunk","remainder","flush","sizeOf","enqueue","close","chunkMode","modeOf","chunkSize","bufferSize","newSize","merge","warn","ReadableStream","createBufferedReadable","push","s","Error","byteLength","length","allowBuffer","Buffer"],"sources":["/Users/tuvyakhatter/Desktop/pipecat_voicebot/~/Desktop/sow_editor/node_modules/@smithy/util-stream/dist-es/createBufferedReadableStream.js"],"sourcesContent":["import { ByteArrayCollector } from \"./ByteArrayCollector\";\nexport function createBufferedReadableStream(upstream, size, logger) {\n    const reader = upstream.getReader();\n    let streamBufferingLoggedWarning = false;\n    let bytesSeen = 0;\n    const buffers = [\"\", new ByteArrayCollector((size) => new Uint8Array(size))];\n    let mode = -1;\n    const pull = async (controller) => {\n        const { value, done } = await reader.read();\n        const chunk = value;\n        if (done) {\n            if (mode !== -1) {\n                const remainder = flush(buffers, mode);\n                if (sizeOf(remainder) > 0) {\n                    controller.enqueue(remainder);\n                }\n            }\n            controller.close();\n        }\n        else {\n            const chunkMode = modeOf(chunk, false);\n            if (mode !== chunkMode) {\n                if (mode >= 0) {\n                    controller.enqueue(flush(buffers, mode));\n                }\n                mode = chunkMode;\n            }\n            if (mode === -1) {\n                controller.enqueue(chunk);\n                return;\n            }\n            const chunkSize = sizeOf(chunk);\n            bytesSeen += chunkSize;\n            const bufferSize = sizeOf(buffers[mode]);\n            if (chunkSize >= size && bufferSize === 0) {\n                controller.enqueue(chunk);\n            }\n            else {\n                const newSize = merge(buffers, mode, chunk);\n                if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {\n                    streamBufferingLoggedWarning = true;\n                    logger?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);\n                }\n                if (newSize >= size) {\n                    controller.enqueue(flush(buffers, mode));\n                }\n                else {\n                    await pull(controller);\n                }\n            }\n        }\n    };\n    return new ReadableStream({\n        pull,\n    });\n}\nexport const createBufferedReadable = createBufferedReadableStream;\nexport function merge(buffers, mode, chunk) {\n    switch (mode) {\n        case 0:\n            buffers[0] += chunk;\n            return sizeOf(buffers[0]);\n        case 1:\n        case 2:\n            buffers[mode].push(chunk);\n            return sizeOf(buffers[mode]);\n    }\n}\nexport function flush(buffers, mode) {\n    switch (mode) {\n        case 0:\n            const s = buffers[0];\n            buffers[0] = \"\";\n            return s;\n        case 1:\n        case 2:\n            return buffers[mode].flush();\n    }\n    throw new Error(`@smithy/util-stream - invalid index ${mode} given to flush()`);\n}\nexport function sizeOf(chunk) {\n    return chunk?.byteLength ?? chunk?.length ?? 0;\n}\nexport function modeOf(chunk, allowBuffer = true) {\n    if (allowBuffer && typeof Buffer !== \"undefined\" && chunk instanceof Buffer) {\n        return 2;\n    }\n    if (chunk instanceof Uint8Array) {\n        return 1;\n    }\n    if (typeof chunk === \"string\") {\n        return 0;\n    }\n    return -1;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}