{"ast":null,"code":"export const createIsIdentityExpiredFunction = expirationMs => identity => doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;\nexport const EXPIRATION_MS = 300000;\nexport const isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);\nexport const doesIdentityRequireRefresh = identity => identity.expiration !== undefined;\nexport const memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {\n  if (provider === undefined) {\n    return undefined;\n  }\n  const normalizedProvider = typeof provider !== \"function\" ? async () => Promise.resolve(provider) : provider;\n  let resolved;\n  let pending;\n  let hasResult;\n  let isConstant = false;\n  const coalesceProvider = async options => {\n    if (!pending) {\n      pending = normalizedProvider(options);\n    }\n    try {\n      resolved = await pending;\n      hasResult = true;\n      isConstant = false;\n    } finally {\n      pending = undefined;\n    }\n    return resolved;\n  };\n  if (isExpired === undefined) {\n    return async options => {\n      if (!hasResult || options?.forceRefresh) {\n        resolved = await coalesceProvider(options);\n      }\n      return resolved;\n    };\n  }\n  return async options => {\n    if (!hasResult || options?.forceRefresh) {\n      resolved = await coalesceProvider(options);\n    }\n    if (isConstant) {\n      return resolved;\n    }\n    if (!requiresRefresh(resolved)) {\n      isConstant = true;\n      return resolved;\n    }\n    if (isExpired(resolved)) {\n      await coalesceProvider(options);\n      return resolved;\n    }\n    return resolved;\n  };\n};","map":{"version":3,"names":["createIsIdentityExpiredFunction","expirationMs","identity","doesIdentityRequireRefresh","expiration","getTime","Date","now","EXPIRATION_MS","isIdentityExpired","undefined","memoizeIdentityProvider","provider","isExpired","requiresRefresh","normalizedProvider","Promise","resolve","resolved","pending","hasResult","isConstant","coalesceProvider","options","forceRefresh"],"sources":["/Users/tuvyakhatter/Desktop/pipecat_voicebot/~/Desktop/sow_editor/node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js"],"sourcesContent":["export const createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;\nexport const EXPIRATION_MS = 300000;\nexport const isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);\nexport const doesIdentityRequireRefresh = (identity) => identity.expiration !== undefined;\nexport const memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {\n    if (provider === undefined) {\n        return undefined;\n    }\n    const normalizedProvider = typeof provider !== \"function\" ? async () => Promise.resolve(provider) : provider;\n    let resolved;\n    let pending;\n    let hasResult;\n    let isConstant = false;\n    const coalesceProvider = async (options) => {\n        if (!pending) {\n            pending = normalizedProvider(options);\n        }\n        try {\n            resolved = await pending;\n            hasResult = true;\n            isConstant = false;\n        }\n        finally {\n            pending = undefined;\n        }\n        return resolved;\n    };\n    if (isExpired === undefined) {\n        return async (options) => {\n            if (!hasResult || options?.forceRefresh) {\n                resolved = await coalesceProvider(options);\n            }\n            return resolved;\n        };\n    }\n    return async (options) => {\n        if (!hasResult || options?.forceRefresh) {\n            resolved = await coalesceProvider(options);\n        }\n        if (isConstant) {\n            return resolved;\n        }\n        if (!requiresRefresh(resolved)) {\n            isConstant = true;\n            return resolved;\n        }\n        if (isExpired(resolved)) {\n            await coalesceProvider(options);\n            return resolved;\n        }\n        return resolved;\n    };\n};\n"],"mappings":"AAAA,OAAO,MAAMA,+BAA+B,GAAIC,YAAY,IAAMC,QAAQ,IAAKC,0BAA0B,CAACD,QAAQ,CAAC,IAAIA,QAAQ,CAACE,UAAU,CAACC,OAAO,CAAC,CAAC,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGN,YAAY;AAChL,OAAO,MAAMO,aAAa,GAAG,MAAM;AACnC,OAAO,MAAMC,iBAAiB,GAAGT,+BAA+B,CAACQ,aAAa,CAAC;AAC/E,OAAO,MAAML,0BAA0B,GAAID,QAAQ,IAAKA,QAAQ,CAACE,UAAU,KAAKM,SAAS;AACzF,OAAO,MAAMC,uBAAuB,GAAGA,CAACC,QAAQ,EAAEC,SAAS,EAAEC,eAAe,KAAK;EAC7E,IAAIF,QAAQ,KAAKF,SAAS,EAAE;IACxB,OAAOA,SAAS;EACpB;EACA,MAAMK,kBAAkB,GAAG,OAAOH,QAAQ,KAAK,UAAU,GAAG,YAAYI,OAAO,CAACC,OAAO,CAACL,QAAQ,CAAC,GAAGA,QAAQ;EAC5G,IAAIM,QAAQ;EACZ,IAAIC,OAAO;EACX,IAAIC,SAAS;EACb,IAAIC,UAAU,GAAG,KAAK;EACtB,MAAMC,gBAAgB,GAAG,MAAOC,OAAO,IAAK;IACxC,IAAI,CAACJ,OAAO,EAAE;MACVA,OAAO,GAAGJ,kBAAkB,CAACQ,OAAO,CAAC;IACzC;IACA,IAAI;MACAL,QAAQ,GAAG,MAAMC,OAAO;MACxBC,SAAS,GAAG,IAAI;MAChBC,UAAU,GAAG,KAAK;IACtB,CAAC,SACO;MACJF,OAAO,GAAGT,SAAS;IACvB;IACA,OAAOQ,QAAQ;EACnB,CAAC;EACD,IAAIL,SAAS,KAAKH,SAAS,EAAE;IACzB,OAAO,MAAOa,OAAO,IAAK;MACtB,IAAI,CAACH,SAAS,IAAIG,OAAO,EAAEC,YAAY,EAAE;QACrCN,QAAQ,GAAG,MAAMI,gBAAgB,CAACC,OAAO,CAAC;MAC9C;MACA,OAAOL,QAAQ;IACnB,CAAC;EACL;EACA,OAAO,MAAOK,OAAO,IAAK;IACtB,IAAI,CAACH,SAAS,IAAIG,OAAO,EAAEC,YAAY,EAAE;MACrCN,QAAQ,GAAG,MAAMI,gBAAgB,CAACC,OAAO,CAAC;IAC9C;IACA,IAAIF,UAAU,EAAE;MACZ,OAAOH,QAAQ;IACnB;IACA,IAAI,CAACJ,eAAe,CAACI,QAAQ,CAAC,EAAE;MAC5BG,UAAU,GAAG,IAAI;MACjB,OAAOH,QAAQ;IACnB;IACA,IAAIL,SAAS,CAACK,QAAQ,CAAC,EAAE;MACrB,MAAMI,gBAAgB,CAACC,OAAO,CAAC;MAC/B,OAAOL,QAAQ;IACnB;IACA,OAAOA,QAAQ;EACnB,CAAC;AACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}