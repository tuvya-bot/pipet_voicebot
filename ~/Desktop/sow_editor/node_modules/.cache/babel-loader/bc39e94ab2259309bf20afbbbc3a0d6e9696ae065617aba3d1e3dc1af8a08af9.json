{"ast":null,"code":"import { HttpRequest, HttpResponse } from \"@smithy/protocol-http\";\nimport { isServerError, isThrottlingError, isTransientError } from \"@smithy/service-error-classification\";\nimport { NoOpLogger } from \"@smithy/smithy-client\";\nimport { INVOCATION_ID_HEADER, REQUEST_HEADER } from \"@smithy/util-retry\";\nimport { v4 } from \"uuid\";\nimport { isStreamingPayload } from \"./isStreamingPayload/isStreamingPayload\";\nimport { asSdkError } from \"./util\";\nexport const retryMiddleware = options => (next, context) => async args => {\n  let retryStrategy = await options.retryStrategy();\n  const maxAttempts = await options.maxAttempts();\n  if (isRetryStrategyV2(retryStrategy)) {\n    retryStrategy = retryStrategy;\n    let retryToken = await retryStrategy.acquireInitialRetryToken(context[\"partition_id\"]);\n    let lastError = new Error();\n    let attempts = 0;\n    let totalRetryDelay = 0;\n    const {\n      request\n    } = args;\n    const isRequest = HttpRequest.isInstance(request);\n    if (isRequest) {\n      request.headers[INVOCATION_ID_HEADER] = v4();\n    }\n    while (true) {\n      try {\n        if (isRequest) {\n          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n        }\n        const {\n          response,\n          output\n        } = await next(args);\n        retryStrategy.recordSuccess(retryToken);\n        output.$metadata.attempts = attempts + 1;\n        output.$metadata.totalRetryDelay = totalRetryDelay;\n        return {\n          response,\n          output\n        };\n      } catch (e) {\n        const retryErrorInfo = getRetryErrorInfo(e);\n        lastError = asSdkError(e);\n        if (isRequest && isStreamingPayload(request)) {\n          (context.logger instanceof NoOpLogger ? console : context.logger)?.warn(\"An error was encountered in a non-retryable streaming request.\");\n          throw lastError;\n        }\n        try {\n          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);\n        } catch (refreshError) {\n          if (!lastError.$metadata) {\n            lastError.$metadata = {};\n          }\n          lastError.$metadata.attempts = attempts + 1;\n          lastError.$metadata.totalRetryDelay = totalRetryDelay;\n          throw lastError;\n        }\n        attempts = retryToken.getRetryCount();\n        const delay = retryToken.getRetryDelay();\n        totalRetryDelay += delay;\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  } else {\n    retryStrategy = retryStrategy;\n    if (retryStrategy?.mode) context.userAgent = [...(context.userAgent || []), [\"cfg/retry-mode\", retryStrategy.mode]];\n    return retryStrategy.retry(next, args);\n  }\n};\nconst isRetryStrategyV2 = retryStrategy => typeof retryStrategy.acquireInitialRetryToken !== \"undefined\" && typeof retryStrategy.refreshRetryTokenForRetry !== \"undefined\" && typeof retryStrategy.recordSuccess !== \"undefined\";\nconst getRetryErrorInfo = error => {\n  const errorInfo = {\n    error,\n    errorType: getRetryErrorType(error)\n  };\n  const retryAfterHint = getRetryAfterHint(error.$response);\n  if (retryAfterHint) {\n    errorInfo.retryAfterHint = retryAfterHint;\n  }\n  return errorInfo;\n};\nconst getRetryErrorType = error => {\n  if (isThrottlingError(error)) return \"THROTTLING\";\n  if (isTransientError(error)) return \"TRANSIENT\";\n  if (isServerError(error)) return \"SERVER_ERROR\";\n  return \"CLIENT_ERROR\";\n};\nexport const retryMiddlewareOptions = {\n  name: \"retryMiddleware\",\n  tags: [\"RETRY\"],\n  step: \"finalizeRequest\",\n  priority: \"high\",\n  override: true\n};\nexport const getRetryPlugin = options => ({\n  applyToStack: clientStack => {\n    clientStack.add(retryMiddleware(options), retryMiddlewareOptions);\n  }\n});\nexport const getRetryAfterHint = response => {\n  if (!HttpResponse.isInstance(response)) return;\n  const retryAfterHeaderName = Object.keys(response.headers).find(key => key.toLowerCase() === \"retry-after\");\n  if (!retryAfterHeaderName) return;\n  const retryAfter = response.headers[retryAfterHeaderName];\n  const retryAfterSeconds = Number(retryAfter);\n  if (!Number.isNaN(retryAfterSeconds)) return new Date(retryAfterSeconds * 1000);\n  const retryAfterDate = new Date(retryAfter);\n  return retryAfterDate;\n};","map":{"version":3,"names":["HttpRequest","HttpResponse","isServerError","isThrottlingError","isTransientError","NoOpLogger","INVOCATION_ID_HEADER","REQUEST_HEADER","v4","isStreamingPayload","asSdkError","retryMiddleware","options","next","context","args","retryStrategy","maxAttempts","isRetryStrategyV2","retryToken","acquireInitialRetryToken","lastError","Error","attempts","totalRetryDelay","request","isRequest","isInstance","headers","response","output","recordSuccess","$metadata","e","retryErrorInfo","getRetryErrorInfo","logger","console","warn","refreshRetryTokenForRetry","refreshError","getRetryCount","delay","getRetryDelay","Promise","resolve","setTimeout","mode","userAgent","retry","error","errorInfo","errorType","getRetryErrorType","retryAfterHint","getRetryAfterHint","$response","retryMiddlewareOptions","name","tags","step","priority","override","getRetryPlugin","applyToStack","clientStack","add","retryAfterHeaderName","Object","keys","find","key","toLowerCase","retryAfter","retryAfterSeconds","Number","isNaN","Date","retryAfterDate"],"sources":["/Users/tuvyakhatter/Desktop/pipecat_voicebot/~/Desktop/sow_editor/node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js"],"sourcesContent":["import { HttpRequest, HttpResponse } from \"@smithy/protocol-http\";\nimport { isServerError, isThrottlingError, isTransientError } from \"@smithy/service-error-classification\";\nimport { NoOpLogger } from \"@smithy/smithy-client\";\nimport { INVOCATION_ID_HEADER, REQUEST_HEADER } from \"@smithy/util-retry\";\nimport { v4 } from \"uuid\";\nimport { isStreamingPayload } from \"./isStreamingPayload/isStreamingPayload\";\nimport { asSdkError } from \"./util\";\nexport const retryMiddleware = (options) => (next, context) => async (args) => {\n    let retryStrategy = await options.retryStrategy();\n    const maxAttempts = await options.maxAttempts();\n    if (isRetryStrategyV2(retryStrategy)) {\n        retryStrategy = retryStrategy;\n        let retryToken = await retryStrategy.acquireInitialRetryToken(context[\"partition_id\"]);\n        let lastError = new Error();\n        let attempts = 0;\n        let totalRetryDelay = 0;\n        const { request } = args;\n        const isRequest = HttpRequest.isInstance(request);\n        if (isRequest) {\n            request.headers[INVOCATION_ID_HEADER] = v4();\n        }\n        while (true) {\n            try {\n                if (isRequest) {\n                    request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n                }\n                const { response, output } = await next(args);\n                retryStrategy.recordSuccess(retryToken);\n                output.$metadata.attempts = attempts + 1;\n                output.$metadata.totalRetryDelay = totalRetryDelay;\n                return { response, output };\n            }\n            catch (e) {\n                const retryErrorInfo = getRetryErrorInfo(e);\n                lastError = asSdkError(e);\n                if (isRequest && isStreamingPayload(request)) {\n                    (context.logger instanceof NoOpLogger ? console : context.logger)?.warn(\"An error was encountered in a non-retryable streaming request.\");\n                    throw lastError;\n                }\n                try {\n                    retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);\n                }\n                catch (refreshError) {\n                    if (!lastError.$metadata) {\n                        lastError.$metadata = {};\n                    }\n                    lastError.$metadata.attempts = attempts + 1;\n                    lastError.$metadata.totalRetryDelay = totalRetryDelay;\n                    throw lastError;\n                }\n                attempts = retryToken.getRetryCount();\n                const delay = retryToken.getRetryDelay();\n                totalRetryDelay += delay;\n                await new Promise((resolve) => setTimeout(resolve, delay));\n            }\n        }\n    }\n    else {\n        retryStrategy = retryStrategy;\n        if (retryStrategy?.mode)\n            context.userAgent = [...(context.userAgent || []), [\"cfg/retry-mode\", retryStrategy.mode]];\n        return retryStrategy.retry(next, args);\n    }\n};\nconst isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== \"undefined\" &&\n    typeof retryStrategy.refreshRetryTokenForRetry !== \"undefined\" &&\n    typeof retryStrategy.recordSuccess !== \"undefined\";\nconst getRetryErrorInfo = (error) => {\n    const errorInfo = {\n        error,\n        errorType: getRetryErrorType(error),\n    };\n    const retryAfterHint = getRetryAfterHint(error.$response);\n    if (retryAfterHint) {\n        errorInfo.retryAfterHint = retryAfterHint;\n    }\n    return errorInfo;\n};\nconst getRetryErrorType = (error) => {\n    if (isThrottlingError(error))\n        return \"THROTTLING\";\n    if (isTransientError(error))\n        return \"TRANSIENT\";\n    if (isServerError(error))\n        return \"SERVER_ERROR\";\n    return \"CLIENT_ERROR\";\n};\nexport const retryMiddlewareOptions = {\n    name: \"retryMiddleware\",\n    tags: [\"RETRY\"],\n    step: \"finalizeRequest\",\n    priority: \"high\",\n    override: true,\n};\nexport const getRetryPlugin = (options) => ({\n    applyToStack: (clientStack) => {\n        clientStack.add(retryMiddleware(options), retryMiddlewareOptions);\n    },\n});\nexport const getRetryAfterHint = (response) => {\n    if (!HttpResponse.isInstance(response))\n        return;\n    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === \"retry-after\");\n    if (!retryAfterHeaderName)\n        return;\n    const retryAfter = response.headers[retryAfterHeaderName];\n    const retryAfterSeconds = Number(retryAfter);\n    if (!Number.isNaN(retryAfterSeconds))\n        return new Date(retryAfterSeconds * 1000);\n    const retryAfterDate = new Date(retryAfter);\n    return retryAfterDate;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}