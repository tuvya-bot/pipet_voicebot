{"ast":null,"code":"import { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, NO_RETRY_INCREMENT, RETRY_COST, THROTTLING_RETRY_DELAY_BASE, TIMEOUT_RETRY_COST } from \"./constants\";\nimport { getDefaultRetryBackoffStrategy } from \"./defaultRetryBackoffStrategy\";\nimport { createDefaultRetryToken } from \"./defaultRetryToken\";\nexport class StandardRetryStrategy {\n  constructor(maxAttempts) {\n    this.maxAttempts = maxAttempts;\n    this.mode = RETRY_MODES.STANDARD;\n    this.capacity = INITIAL_RETRY_TOKENS;\n    this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();\n    this.maxAttemptsProvider = typeof maxAttempts === \"function\" ? maxAttempts : async () => maxAttempts;\n  }\n  async acquireInitialRetryToken(retryTokenScope) {\n    return createDefaultRetryToken({\n      retryDelay: DEFAULT_RETRY_DELAY_BASE,\n      retryCount: 0\n    });\n  }\n  async refreshRetryTokenForRetry(token, errorInfo) {\n    const maxAttempts = await this.getMaxAttempts();\n    if (this.shouldRetry(token, errorInfo, maxAttempts)) {\n      const errorType = errorInfo.errorType;\n      this.retryBackoffStrategy.setDelayBase(errorType === \"THROTTLING\" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);\n      const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());\n      const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;\n      const capacityCost = this.getCapacityCost(errorType);\n      this.capacity -= capacityCost;\n      return createDefaultRetryToken({\n        retryDelay,\n        retryCount: token.getRetryCount() + 1,\n        retryCost: capacityCost\n      });\n    }\n    throw new Error(\"No retry token available\");\n  }\n  recordSuccess(token) {\n    this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));\n  }\n  getCapacity() {\n    return this.capacity;\n  }\n  async getMaxAttempts() {\n    try {\n      return await this.maxAttemptsProvider();\n    } catch (error) {\n      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);\n      return DEFAULT_MAX_ATTEMPTS;\n    }\n  }\n  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {\n    const attempts = tokenToRenew.getRetryCount() + 1;\n    return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);\n  }\n  getCapacityCost(errorType) {\n    return errorType === \"TRANSIENT\" ? TIMEOUT_RETRY_COST : RETRY_COST;\n  }\n  isRetryableError(errorType) {\n    return errorType === \"THROTTLING\" || errorType === \"TRANSIENT\";\n  }\n}","map":{"version":3,"names":["DEFAULT_MAX_ATTEMPTS","RETRY_MODES","DEFAULT_RETRY_DELAY_BASE","INITIAL_RETRY_TOKENS","NO_RETRY_INCREMENT","RETRY_COST","THROTTLING_RETRY_DELAY_BASE","TIMEOUT_RETRY_COST","getDefaultRetryBackoffStrategy","createDefaultRetryToken","StandardRetryStrategy","constructor","maxAttempts","mode","STANDARD","capacity","retryBackoffStrategy","maxAttemptsProvider","acquireInitialRetryToken","retryTokenScope","retryDelay","retryCount","refreshRetryTokenForRetry","token","errorInfo","getMaxAttempts","shouldRetry","errorType","setDelayBase","delayFromErrorType","computeNextBackoffDelay","getRetryCount","retryAfterHint","Math","max","getTime","Date","now","capacityCost","getCapacityCost","retryCost","Error","recordSuccess","getRetryCost","getCapacity","error","console","warn","tokenToRenew","attempts","isRetryableError"],"sources":["/Users/tuvyakhatter/Desktop/pipecat_voicebot/~/Desktop/sow_editor/node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js"],"sourcesContent":["import { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, NO_RETRY_INCREMENT, RETRY_COST, THROTTLING_RETRY_DELAY_BASE, TIMEOUT_RETRY_COST, } from \"./constants\";\nimport { getDefaultRetryBackoffStrategy } from \"./defaultRetryBackoffStrategy\";\nimport { createDefaultRetryToken } from \"./defaultRetryToken\";\nexport class StandardRetryStrategy {\n    constructor(maxAttempts) {\n        this.maxAttempts = maxAttempts;\n        this.mode = RETRY_MODES.STANDARD;\n        this.capacity = INITIAL_RETRY_TOKENS;\n        this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();\n        this.maxAttemptsProvider = typeof maxAttempts === \"function\" ? maxAttempts : async () => maxAttempts;\n    }\n    async acquireInitialRetryToken(retryTokenScope) {\n        return createDefaultRetryToken({\n            retryDelay: DEFAULT_RETRY_DELAY_BASE,\n            retryCount: 0,\n        });\n    }\n    async refreshRetryTokenForRetry(token, errorInfo) {\n        const maxAttempts = await this.getMaxAttempts();\n        if (this.shouldRetry(token, errorInfo, maxAttempts)) {\n            const errorType = errorInfo.errorType;\n            this.retryBackoffStrategy.setDelayBase(errorType === \"THROTTLING\" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);\n            const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());\n            const retryDelay = errorInfo.retryAfterHint\n                ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType)\n                : delayFromErrorType;\n            const capacityCost = this.getCapacityCost(errorType);\n            this.capacity -= capacityCost;\n            return createDefaultRetryToken({\n                retryDelay,\n                retryCount: token.getRetryCount() + 1,\n                retryCost: capacityCost,\n            });\n        }\n        throw new Error(\"No retry token available\");\n    }\n    recordSuccess(token) {\n        this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));\n    }\n    getCapacity() {\n        return this.capacity;\n    }\n    async getMaxAttempts() {\n        try {\n            return await this.maxAttemptsProvider();\n        }\n        catch (error) {\n            console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);\n            return DEFAULT_MAX_ATTEMPTS;\n        }\n    }\n    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {\n        const attempts = tokenToRenew.getRetryCount() + 1;\n        return (attempts < maxAttempts &&\n            this.capacity >= this.getCapacityCost(errorInfo.errorType) &&\n            this.isRetryableError(errorInfo.errorType));\n    }\n    getCapacityCost(errorType) {\n        return errorType === \"TRANSIENT\" ? TIMEOUT_RETRY_COST : RETRY_COST;\n    }\n    isRetryableError(errorType) {\n        return errorType === \"THROTTLING\" || errorType === \"TRANSIENT\";\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}