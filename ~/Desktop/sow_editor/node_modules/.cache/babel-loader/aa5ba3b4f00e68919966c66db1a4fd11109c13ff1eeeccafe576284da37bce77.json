{"ast":null,"code":"import { HttpBindingProtocol, HttpInterceptingShapeDeserializer, HttpInterceptingShapeSerializer } from \"@smithy/core/protocols\";\nimport { NormalizedSchema, SCHEMA, TypeRegistry } from \"@smithy/core/schema\";\nimport { calculateBodyLength } from \"@smithy/util-body-length-browser\";\nimport { JsonCodec } from \"./JsonCodec\";\nimport { loadRestJsonErrorCode } from \"./parseJsonBody\";\nexport class AwsRestJsonProtocol extends HttpBindingProtocol {\n  serializer;\n  deserializer;\n  codec;\n  constructor({\n    defaultNamespace\n  }) {\n    super({\n      defaultNamespace\n    });\n    const settings = {\n      timestampFormat: {\n        useTrait: true,\n        default: SCHEMA.TIMESTAMP_EPOCH_SECONDS\n      },\n      httpBindings: true,\n      jsonName: true\n    };\n    this.codec = new JsonCodec(settings);\n    this.serializer = new HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);\n    this.deserializer = new HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);\n  }\n  getShapeId() {\n    return \"aws.protocols#restJson1\";\n  }\n  getPayloadCodec() {\n    return this.codec;\n  }\n  setSerdeContext(serdeContext) {\n    this.codec.setSerdeContext(serdeContext);\n    super.setSerdeContext(serdeContext);\n  }\n  async serializeRequest(operationSchema, input, context) {\n    const request = await super.serializeRequest(operationSchema, input, context);\n    const inputSchema = NormalizedSchema.of(operationSchema.input);\n    const members = inputSchema.getMemberSchemas();\n    if (!request.headers[\"content-type\"]) {\n      const httpPayloadMember = Object.values(members).find(m => {\n        return !!m.getMergedTraits().httpPayload;\n      });\n      if (httpPayloadMember) {\n        const mediaType = httpPayloadMember.getMergedTraits().mediaType;\n        if (mediaType) {\n          request.headers[\"content-type\"] = mediaType;\n        } else if (httpPayloadMember.isStringSchema()) {\n          request.headers[\"content-type\"] = \"text/plain\";\n        } else if (httpPayloadMember.isBlobSchema()) {\n          request.headers[\"content-type\"] = \"application/octet-stream\";\n        } else {\n          request.headers[\"content-type\"] = \"application/json\";\n        }\n      } else if (!inputSchema.isUnitSchema()) {\n        const hasBody = Object.values(members).find(m => {\n          const {\n            httpQuery,\n            httpQueryParams,\n            httpHeader,\n            httpLabel,\n            httpPrefixHeaders\n          } = m.getMergedTraits();\n          return !httpQuery && !httpQueryParams && !httpHeader && !httpLabel && httpPrefixHeaders === void 0;\n        });\n        if (hasBody) {\n          request.headers[\"content-type\"] = \"application/json\";\n        }\n      }\n    }\n    if (request.headers[\"content-type\"] && !request.body) {\n      request.body = \"{}\";\n    }\n    if (request.body) {\n      try {\n        request.headers[\"content-length\"] = String(calculateBodyLength(request.body));\n      } catch (e) {}\n    }\n    return request;\n  }\n  async handleError(operationSchema, context, response, dataObject, metadata) {\n    const errorIdentifier = loadRestJsonErrorCode(response, dataObject) ?? \"Unknown\";\n    let namespace = this.options.defaultNamespace;\n    let errorName = errorIdentifier;\n    if (errorIdentifier.includes(\"#\")) {\n      [namespace, errorName] = errorIdentifier.split(\"#\");\n    }\n    const registry = TypeRegistry.for(namespace);\n    let errorSchema;\n    try {\n      errorSchema = registry.getSchema(errorIdentifier);\n    } catch (e) {\n      const baseExceptionSchema = TypeRegistry.for(\"smithy.ts.sdk.synthetic.\" + namespace).getBaseException();\n      if (baseExceptionSchema) {\n        const ErrorCtor = baseExceptionSchema.ctor;\n        throw Object.assign(new ErrorCtor(errorName), dataObject);\n      }\n      throw new Error(errorName);\n    }\n    const ns = NormalizedSchema.of(errorSchema);\n    const message = dataObject.message ?? dataObject.Message ?? \"Unknown\";\n    const exception = new errorSchema.ctor(message);\n    await this.deserializeHttpMessage(errorSchema, context, response, dataObject);\n    const output = {};\n    for (const [name, member] of ns.structIterator()) {\n      const target = member.getMergedTraits().jsonName ?? name;\n      output[name] = this.codec.createDeserializer().readObject(member, dataObject[target]);\n    }\n    Object.assign(exception, {\n      $metadata: metadata,\n      $response: response,\n      $fault: ns.getMergedTraits().error,\n      message,\n      ...output\n    });\n    throw exception;\n  }\n}","map":{"version":3,"names":["HttpBindingProtocol","HttpInterceptingShapeDeserializer","HttpInterceptingShapeSerializer","NormalizedSchema","SCHEMA","TypeRegistry","calculateBodyLength","JsonCodec","loadRestJsonErrorCode","AwsRestJsonProtocol","serializer","deserializer","codec","constructor","defaultNamespace","settings","timestampFormat","useTrait","default","TIMESTAMP_EPOCH_SECONDS","httpBindings","jsonName","createSerializer","createDeserializer","getShapeId","getPayloadCodec","setSerdeContext","serdeContext","serializeRequest","operationSchema","input","context","request","inputSchema","of","members","getMemberSchemas","headers","httpPayloadMember","Object","values","find","m","getMergedTraits","httpPayload","mediaType","isStringSchema","isBlobSchema","isUnitSchema","hasBody","httpQuery","httpQueryParams","httpHeader","httpLabel","httpPrefixHeaders","body","String","e","handleError","response","dataObject","metadata","errorIdentifier","namespace","options","errorName","includes","split","registry","for","errorSchema","getSchema","baseExceptionSchema","getBaseException","ErrorCtor","ctor","assign","Error","ns","message","Message","exception","deserializeHttpMessage","output","name","member","structIterator","target","readObject","$metadata","$response","$fault","error"],"sources":["/Users/tuvyakhatter/Desktop/pipecat_voicebot/~/Desktop/sow_editor/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsRestJsonProtocol.js"],"sourcesContent":["import { HttpBindingProtocol, HttpInterceptingShapeDeserializer, HttpInterceptingShapeSerializer, } from \"@smithy/core/protocols\";\nimport { NormalizedSchema, SCHEMA, TypeRegistry } from \"@smithy/core/schema\";\nimport { calculateBodyLength } from \"@smithy/util-body-length-browser\";\nimport { JsonCodec } from \"./JsonCodec\";\nimport { loadRestJsonErrorCode } from \"./parseJsonBody\";\nexport class AwsRestJsonProtocol extends HttpBindingProtocol {\n    serializer;\n    deserializer;\n    codec;\n    constructor({ defaultNamespace }) {\n        super({\n            defaultNamespace,\n        });\n        const settings = {\n            timestampFormat: {\n                useTrait: true,\n                default: SCHEMA.TIMESTAMP_EPOCH_SECONDS,\n            },\n            httpBindings: true,\n            jsonName: true,\n        };\n        this.codec = new JsonCodec(settings);\n        this.serializer = new HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);\n        this.deserializer = new HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);\n    }\n    getShapeId() {\n        return \"aws.protocols#restJson1\";\n    }\n    getPayloadCodec() {\n        return this.codec;\n    }\n    setSerdeContext(serdeContext) {\n        this.codec.setSerdeContext(serdeContext);\n        super.setSerdeContext(serdeContext);\n    }\n    async serializeRequest(operationSchema, input, context) {\n        const request = await super.serializeRequest(operationSchema, input, context);\n        const inputSchema = NormalizedSchema.of(operationSchema.input);\n        const members = inputSchema.getMemberSchemas();\n        if (!request.headers[\"content-type\"]) {\n            const httpPayloadMember = Object.values(members).find((m) => {\n                return !!m.getMergedTraits().httpPayload;\n            });\n            if (httpPayloadMember) {\n                const mediaType = httpPayloadMember.getMergedTraits().mediaType;\n                if (mediaType) {\n                    request.headers[\"content-type\"] = mediaType;\n                }\n                else if (httpPayloadMember.isStringSchema()) {\n                    request.headers[\"content-type\"] = \"text/plain\";\n                }\n                else if (httpPayloadMember.isBlobSchema()) {\n                    request.headers[\"content-type\"] = \"application/octet-stream\";\n                }\n                else {\n                    request.headers[\"content-type\"] = \"application/json\";\n                }\n            }\n            else if (!inputSchema.isUnitSchema()) {\n                const hasBody = Object.values(members).find((m) => {\n                    const { httpQuery, httpQueryParams, httpHeader, httpLabel, httpPrefixHeaders } = m.getMergedTraits();\n                    return !httpQuery && !httpQueryParams && !httpHeader && !httpLabel && httpPrefixHeaders === void 0;\n                });\n                if (hasBody) {\n                    request.headers[\"content-type\"] = \"application/json\";\n                }\n            }\n        }\n        if (request.headers[\"content-type\"] && !request.body) {\n            request.body = \"{}\";\n        }\n        if (request.body) {\n            try {\n                request.headers[\"content-length\"] = String(calculateBodyLength(request.body));\n            }\n            catch (e) { }\n        }\n        return request;\n    }\n    async handleError(operationSchema, context, response, dataObject, metadata) {\n        const errorIdentifier = loadRestJsonErrorCode(response, dataObject) ?? \"Unknown\";\n        let namespace = this.options.defaultNamespace;\n        let errorName = errorIdentifier;\n        if (errorIdentifier.includes(\"#\")) {\n            [namespace, errorName] = errorIdentifier.split(\"#\");\n        }\n        const registry = TypeRegistry.for(namespace);\n        let errorSchema;\n        try {\n            errorSchema = registry.getSchema(errorIdentifier);\n        }\n        catch (e) {\n            const baseExceptionSchema = TypeRegistry.for(\"smithy.ts.sdk.synthetic.\" + namespace).getBaseException();\n            if (baseExceptionSchema) {\n                const ErrorCtor = baseExceptionSchema.ctor;\n                throw Object.assign(new ErrorCtor(errorName), dataObject);\n            }\n            throw new Error(errorName);\n        }\n        const ns = NormalizedSchema.of(errorSchema);\n        const message = dataObject.message ?? dataObject.Message ?? \"Unknown\";\n        const exception = new errorSchema.ctor(message);\n        await this.deserializeHttpMessage(errorSchema, context, response, dataObject);\n        const output = {};\n        for (const [name, member] of ns.structIterator()) {\n            const target = member.getMergedTraits().jsonName ?? name;\n            output[name] = this.codec.createDeserializer().readObject(member, dataObject[target]);\n        }\n        Object.assign(exception, {\n            $metadata: metadata,\n            $response: response,\n            $fault: ns.getMergedTraits().error,\n            message,\n            ...output,\n        });\n        throw exception;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}