{"ast":null,"code":"import { create } from 'zustand';\nimport { immer } from 'zustand/middleware/immer';\nimport { subscribeWithSelector } from 'zustand/middleware';\nexport const useSOWStore = create(subscribeWithSelector(immer((set, get) => ({\n  // Document state\n  sections: [],\n  currentSection: null,\n  documentTitle: 'Untitled SOW',\n  // Session state\n  currentSession: null,\n  sessionHistory: [],\n  changeLog: [],\n  // Template state\n  currentTemplate: null,\n  availableTemplates: [],\n  // Chat state\n  chatMessages: [],\n  isClaudeTyping: false,\n  pendingClarifications: [],\n  // UI state\n  selectedText: null,\n  inlineControls: {\n    visible: false,\n    position: {\n      x: 0,\n      y: 0\n    },\n    suggestions: []\n  },\n  // Export state\n  exportInProgress: false,\n  // Actions\n  addSection: section => set(state => {\n    state.sections.push({\n      id: Date.now().toString(),\n      ...section,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    });\n    state.changeLog.push({\n      type: 'ADD_SECTION',\n      sectionId: section.id,\n      timestamp: new Date().toISOString(),\n      data: section\n    });\n  }),\n  updateSection: (sectionId, updates) => set(state => {\n    const sectionIndex = state.sections.findIndex(s => s.id === sectionId);\n    if (sectionIndex !== -1) {\n      const oldSection = {\n        ...state.sections[sectionIndex]\n      };\n      state.sections[sectionIndex] = {\n        ...state.sections[sectionIndex],\n        ...updates,\n        updatedAt: new Date().toISOString()\n      };\n      state.changeLog.push({\n        type: 'UPDATE_SECTION',\n        sectionId,\n        timestamp: new Date().toISOString(),\n        oldData: oldSection,\n        newData: state.sections[sectionIndex]\n      });\n    }\n  }),\n  deleteSection: sectionId => set(state => {\n    const sectionIndex = state.sections.findIndex(s => s.id === sectionId);\n    if (sectionIndex !== -1) {\n      const deletedSection = state.sections[sectionIndex];\n      state.sections.splice(sectionIndex, 1);\n      state.changeLog.push({\n        type: 'DELETE_SECTION',\n        sectionId,\n        timestamp: new Date().toISOString(),\n        data: deletedSection\n      });\n    }\n  }),\n  setCurrentSection: sectionId => set(state => {\n    state.currentSection = sectionId;\n  }),\n  addChatMessage: message => set(state => {\n    state.chatMessages.push({\n      id: Date.now().toString(),\n      ...message,\n      timestamp: new Date().toISOString()\n    });\n  }),\n  setClaudeTyping: isTyping => set(state => {\n    state.isClaudeTyping = isTyping;\n  }),\n  showInlineControls: (position, suggestions) => set(state => {\n    state.inlineControls = {\n      visible: true,\n      position,\n      suggestions\n    };\n  }),\n  hideInlineControls: () => set(state => {\n    state.inlineControls.visible = false;\n  }),\n  acceptSuggestion: suggestionId => set(state => {\n    const suggestion = state.inlineControls.suggestions.find(s => s.id === suggestionId);\n    if (suggestion && state.currentSection) {\n      const sectionIndex = state.sections.findIndex(s => s.id === state.currentSection);\n      if (sectionIndex !== -1) {\n        state.sections[sectionIndex].content = suggestion.content;\n        state.sections[sectionIndex].updatedAt = new Date().toISOString();\n        state.changeLog.push({\n          type: 'ACCEPT_SUGGESTION',\n          sectionId: state.currentSection,\n          suggestionId,\n          timestamp: new Date().toISOString(),\n          data: suggestion\n        });\n      }\n    }\n    state.inlineControls.visible = false;\n  }),\n  rejectSuggestion: suggestionId => set(state => {\n    state.changeLog.push({\n      type: 'REJECT_SUGGESTION',\n      suggestionId,\n      timestamp: new Date().toISOString()\n    });\n    state.inlineControls.visible = false;\n  }),\n  loadTemplate: template => set(state => {\n    state.currentTemplate = template;\n    state.sections = template.sections || [];\n    state.documentTitle = template.title || 'Untitled SOW';\n  }),\n  undo: () => set(state => {\n    // Implement undo logic based on changeLog\n    const lastChange = state.changeLog[state.changeLog.length - 1];\n    if (lastChange) {\n      // Reverse the last change\n      switch (lastChange.type) {\n        case 'ADD_SECTION':\n          state.sections = state.sections.filter(s => s.id !== lastChange.sectionId);\n          break;\n        case 'UPDATE_SECTION':\n          const sectionIndex = state.sections.findIndex(s => s.id === lastChange.sectionId);\n          if (sectionIndex !== -1) {\n            state.sections[sectionIndex] = lastChange.oldData;\n          }\n          break;\n        case 'DELETE_SECTION':\n          state.sections.push(lastChange.data);\n          break;\n      }\n      state.changeLog.pop();\n    }\n  }),\n  exportDocument: async format => {\n    set(state => {\n      state.exportInProgress = true;\n    });\n    try {\n      // Export logic will be implemented in services\n      const {\n        exportService\n      } = await import('../services/exportService');\n      const result = await exportService.export(get().sections, format);\n      return result;\n    } finally {\n      set(state => {\n        state.exportInProgress = false;\n      });\n    }\n  }\n}))));","map":{"version":3,"names":["create","immer","subscribeWithSelector","useSOWStore","set","get","sections","currentSection","documentTitle","currentSession","sessionHistory","changeLog","currentTemplate","availableTemplates","chatMessages","isClaudeTyping","pendingClarifications","selectedText","inlineControls","visible","position","x","y","suggestions","exportInProgress","addSection","section","state","push","id","Date","now","toString","createdAt","toISOString","updatedAt","type","sectionId","timestamp","data","updateSection","updates","sectionIndex","findIndex","s","oldSection","oldData","newData","deleteSection","deletedSection","splice","setCurrentSection","addChatMessage","message","setClaudeTyping","isTyping","showInlineControls","hideInlineControls","acceptSuggestion","suggestionId","suggestion","find","content","rejectSuggestion","loadTemplate","template","title","undo","lastChange","length","filter","pop","exportDocument","format","exportService","result","export"],"sources":["/Users/tuvyakhatter/Desktop/pipecat_voicebot/~/Desktop/sow_editor/src/stores/sowStore.js"],"sourcesContent":["import { create } from 'zustand';\nimport { immer } from 'zustand/middleware/immer';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\nexport const useSOWStore = create(\n  subscribeWithSelector(\n    immer((set, get) => ({\n      // Document state\n      sections: [],\n      currentSection: null,\n      documentTitle: 'Untitled SOW',\n      \n      // Session state\n      currentSession: null,\n      sessionHistory: [],\n      changeLog: [],\n      \n      // Template state\n      currentTemplate: null,\n      availableTemplates: [],\n      \n      // Chat state\n      chatMessages: [],\n      isClaudeTyping: false,\n      pendingClarifications: [],\n      \n      // UI state\n      selectedText: null,\n      inlineControls: {\n        visible: false,\n        position: { x: 0, y: 0 },\n        suggestions: []\n      },\n      \n      // Export state\n      exportInProgress: false,\n      \n      // Actions\n      addSection: (section) => set((state) => {\n        state.sections.push({\n          id: Date.now().toString(),\n          ...section,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString()\n        });\n        state.changeLog.push({\n          type: 'ADD_SECTION',\n          sectionId: section.id,\n          timestamp: new Date().toISOString(),\n          data: section\n        });\n      }),\n      \n      updateSection: (sectionId, updates) => set((state) => {\n        const sectionIndex = state.sections.findIndex(s => s.id === sectionId);\n        if (sectionIndex !== -1) {\n          const oldSection = { ...state.sections[sectionIndex] };\n          state.sections[sectionIndex] = {\n            ...state.sections[sectionIndex],\n            ...updates,\n            updatedAt: new Date().toISOString()\n          };\n          state.changeLog.push({\n            type: 'UPDATE_SECTION',\n            sectionId,\n            timestamp: new Date().toISOString(),\n            oldData: oldSection,\n            newData: state.sections[sectionIndex]\n          });\n        }\n      }),\n      \n      deleteSection: (sectionId) => set((state) => {\n        const sectionIndex = state.sections.findIndex(s => s.id === sectionId);\n        if (sectionIndex !== -1) {\n          const deletedSection = state.sections[sectionIndex];\n          state.sections.splice(sectionIndex, 1);\n          state.changeLog.push({\n            type: 'DELETE_SECTION',\n            sectionId,\n            timestamp: new Date().toISOString(),\n            data: deletedSection\n          });\n        }\n      }),\n      \n      setCurrentSection: (sectionId) => set((state) => {\n        state.currentSection = sectionId;\n      }),\n      \n      addChatMessage: (message) => set((state) => {\n        state.chatMessages.push({\n          id: Date.now().toString(),\n          ...message,\n          timestamp: new Date().toISOString()\n        });\n      }),\n      \n      setClaudeTyping: (isTyping) => set((state) => {\n        state.isClaudeTyping = isTyping;\n      }),\n      \n      showInlineControls: (position, suggestions) => set((state) => {\n        state.inlineControls = {\n          visible: true,\n          position,\n          suggestions\n        };\n      }),\n      \n      hideInlineControls: () => set((state) => {\n        state.inlineControls.visible = false;\n      }),\n      \n      acceptSuggestion: (suggestionId) => set((state) => {\n        const suggestion = state.inlineControls.suggestions.find(s => s.id === suggestionId);\n        if (suggestion && state.currentSection) {\n          const sectionIndex = state.sections.findIndex(s => s.id === state.currentSection);\n          if (sectionIndex !== -1) {\n            state.sections[sectionIndex].content = suggestion.content;\n            state.sections[sectionIndex].updatedAt = new Date().toISOString();\n            state.changeLog.push({\n              type: 'ACCEPT_SUGGESTION',\n              sectionId: state.currentSection,\n              suggestionId,\n              timestamp: new Date().toISOString(),\n              data: suggestion\n            });\n          }\n        }\n        state.inlineControls.visible = false;\n      }),\n      \n      rejectSuggestion: (suggestionId) => set((state) => {\n        state.changeLog.push({\n          type: 'REJECT_SUGGESTION',\n          suggestionId,\n          timestamp: new Date().toISOString()\n        });\n        state.inlineControls.visible = false;\n      }),\n      \n      loadTemplate: (template) => set((state) => {\n        state.currentTemplate = template;\n        state.sections = template.sections || [];\n        state.documentTitle = template.title || 'Untitled SOW';\n      }),\n      \n      undo: () => set((state) => {\n        // Implement undo logic based on changeLog\n        const lastChange = state.changeLog[state.changeLog.length - 1];\n        if (lastChange) {\n          // Reverse the last change\n          switch (lastChange.type) {\n            case 'ADD_SECTION':\n              state.sections = state.sections.filter(s => s.id !== lastChange.sectionId);\n              break;\n            case 'UPDATE_SECTION':\n              const sectionIndex = state.sections.findIndex(s => s.id === lastChange.sectionId);\n              if (sectionIndex !== -1) {\n                state.sections[sectionIndex] = lastChange.oldData;\n              }\n              break;\n            case 'DELETE_SECTION':\n              state.sections.push(lastChange.data);\n              break;\n          }\n          state.changeLog.pop();\n        }\n      }),\n      \n      exportDocument: async (format) => {\n        set((state) => {\n          state.exportInProgress = true;\n        });\n        \n        try {\n          // Export logic will be implemented in services\n          const { exportService } = await import('../services/exportService');\n          const result = await exportService.export(get().sections, format);\n          return result;\n        } finally {\n          set((state) => {\n            state.exportInProgress = false;\n          });\n        }\n      }\n    }))\n  )\n);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}