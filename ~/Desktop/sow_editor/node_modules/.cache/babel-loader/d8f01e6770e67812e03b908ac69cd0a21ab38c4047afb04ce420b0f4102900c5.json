{"ast":null,"code":"import { formatUrl } from \"@aws-sdk/util-format-url\";\nimport { iterableToReadableStream, readableStreamtoIterable } from \"@smithy/eventstream-serde-browser\";\nimport { FetchHttpHandler } from \"@smithy/fetch-http-handler\";\nimport { HttpResponse } from \"@smithy/protocol-http\";\nimport { isWebSocketRequest } from \"./utils\";\nconst DEFAULT_WS_CONNECTION_TIMEOUT_MS = 2000;\nexport class WebSocketFetchHandler {\n  metadata = {\n    handlerProtocol: \"websocket/h1.1\"\n  };\n  config;\n  configPromise;\n  httpHandler;\n  sockets = {};\n  static create(instanceOrOptions, httpHandler = new FetchHttpHandler()) {\n    if (typeof instanceOrOptions?.handle === \"function\") {\n      return instanceOrOptions;\n    }\n    return new WebSocketFetchHandler(instanceOrOptions, httpHandler);\n  }\n  constructor(options, httpHandler = new FetchHttpHandler()) {\n    this.httpHandler = httpHandler;\n    if (typeof options === \"function\") {\n      this.config = {};\n      this.configPromise = options().then(opts => this.config = opts ?? {});\n    } else {\n      this.config = options ?? {};\n      this.configPromise = Promise.resolve(this.config);\n    }\n  }\n  destroy() {\n    for (const [key, sockets] of Object.entries(this.sockets)) {\n      for (const socket of sockets) {\n        socket.close(1000, `Socket closed through destroy() call`);\n      }\n      delete this.sockets[key];\n    }\n  }\n  async handle(request) {\n    if (!isWebSocketRequest(request)) {\n      return this.httpHandler.handle(request);\n    }\n    const url = formatUrl(request);\n    const socket = new WebSocket(url);\n    if (!this.sockets[url]) {\n      this.sockets[url] = [];\n    }\n    this.sockets[url].push(socket);\n    socket.binaryType = \"arraybuffer\";\n    this.config = await this.configPromise;\n    const {\n      connectionTimeout = DEFAULT_WS_CONNECTION_TIMEOUT_MS\n    } = this.config;\n    await this.waitForReady(socket, connectionTimeout);\n    const {\n      body\n    } = request;\n    const bodyStream = getIterator(body);\n    const asyncIterable = this.connect(socket, bodyStream);\n    const outputPayload = toReadableStream(asyncIterable);\n    return {\n      response: new HttpResponse({\n        statusCode: 200,\n        body: outputPayload\n      })\n    };\n  }\n  updateHttpClientConfig(key, value) {\n    this.configPromise = this.configPromise.then(config => {\n      config[key] = value;\n      return config;\n    });\n  }\n  httpHandlerConfigs() {\n    return this.config ?? {};\n  }\n  removeNotUsableSockets(url) {\n    this.sockets[url] = (this.sockets[url] ?? []).filter(socket => ![WebSocket.CLOSING, WebSocket.CLOSED].includes(socket.readyState));\n  }\n  waitForReady(socket, connectionTimeout) {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        this.removeNotUsableSockets(socket.url);\n        reject({\n          $metadata: {\n            httpStatusCode: 500\n          }\n        });\n      }, connectionTimeout);\n      socket.onopen = () => {\n        clearTimeout(timeout);\n        resolve();\n      };\n    });\n  }\n  connect(socket, data) {\n    let streamError = undefined;\n    let socketErrorOccurred = false;\n    let reject = () => {};\n    let resolve = () => {};\n    socket.onmessage = event => {\n      resolve({\n        done: false,\n        value: new Uint8Array(event.data)\n      });\n    };\n    socket.onerror = error => {\n      socketErrorOccurred = true;\n      socket.close();\n      reject(error);\n    };\n    socket.onclose = () => {\n      this.removeNotUsableSockets(socket.url);\n      if (socketErrorOccurred) return;\n      if (streamError) {\n        reject(streamError);\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    };\n    const outputStream = {\n      [Symbol.asyncIterator]: () => ({\n        next: () => {\n          return new Promise((_resolve, _reject) => {\n            resolve = _resolve;\n            reject = _reject;\n          });\n        }\n      })\n    };\n    const send = async () => {\n      try {\n        for await (const inputChunk of data) {\n          socket.send(inputChunk);\n        }\n      } catch (err) {\n        streamError = err;\n      } finally {\n        socket.close(1000);\n      }\n    };\n    send();\n    return outputStream;\n  }\n}\nconst getIterator = stream => {\n  if (stream[Symbol.asyncIterator]) {\n    return stream;\n  }\n  if (isReadableStream(stream)) {\n    return readableStreamtoIterable(stream);\n  }\n  return {\n    [Symbol.asyncIterator]: async function* () {\n      yield stream;\n    }\n  };\n};\nconst toReadableStream = asyncIterable => typeof ReadableStream === \"function\" ? iterableToReadableStream(asyncIterable) : asyncIterable;\nconst isReadableStream = payload => typeof ReadableStream === \"function\" && payload instanceof ReadableStream;","map":{"version":3,"names":["formatUrl","iterableToReadableStream","readableStreamtoIterable","FetchHttpHandler","HttpResponse","isWebSocketRequest","DEFAULT_WS_CONNECTION_TIMEOUT_MS","WebSocketFetchHandler","metadata","handlerProtocol","config","configPromise","httpHandler","sockets","create","instanceOrOptions","handle","constructor","options","then","opts","Promise","resolve","destroy","key","Object","entries","socket","close","request","url","WebSocket","push","binaryType","connectionTimeout","waitForReady","body","bodyStream","getIterator","asyncIterable","connect","outputPayload","toReadableStream","response","statusCode","updateHttpClientConfig","value","httpHandlerConfigs","removeNotUsableSockets","filter","CLOSING","CLOSED","includes","readyState","reject","timeout","setTimeout","$metadata","httpStatusCode","onopen","clearTimeout","data","streamError","undefined","socketErrorOccurred","onmessage","event","done","Uint8Array","onerror","error","onclose","outputStream","Symbol","asyncIterator","next","_resolve","_reject","send","inputChunk","err","stream","isReadableStream","ReadableStream","payload"],"sources":["/Users/tuvyakhatter/Desktop/pipecat_voicebot/~/Desktop/sow_editor/node_modules/@aws-sdk/middleware-websocket/dist-es/websocket-fetch-handler.js"],"sourcesContent":["import { formatUrl } from \"@aws-sdk/util-format-url\";\nimport { iterableToReadableStream, readableStreamtoIterable } from \"@smithy/eventstream-serde-browser\";\nimport { FetchHttpHandler } from \"@smithy/fetch-http-handler\";\nimport { HttpResponse } from \"@smithy/protocol-http\";\nimport { isWebSocketRequest } from \"./utils\";\nconst DEFAULT_WS_CONNECTION_TIMEOUT_MS = 2000;\nexport class WebSocketFetchHandler {\n    metadata = {\n        handlerProtocol: \"websocket/h1.1\",\n    };\n    config;\n    configPromise;\n    httpHandler;\n    sockets = {};\n    static create(instanceOrOptions, httpHandler = new FetchHttpHandler()) {\n        if (typeof instanceOrOptions?.handle === \"function\") {\n            return instanceOrOptions;\n        }\n        return new WebSocketFetchHandler(instanceOrOptions, httpHandler);\n    }\n    constructor(options, httpHandler = new FetchHttpHandler()) {\n        this.httpHandler = httpHandler;\n        if (typeof options === \"function\") {\n            this.config = {};\n            this.configPromise = options().then((opts) => (this.config = opts ?? {}));\n        }\n        else {\n            this.config = options ?? {};\n            this.configPromise = Promise.resolve(this.config);\n        }\n    }\n    destroy() {\n        for (const [key, sockets] of Object.entries(this.sockets)) {\n            for (const socket of sockets) {\n                socket.close(1000, `Socket closed through destroy() call`);\n            }\n            delete this.sockets[key];\n        }\n    }\n    async handle(request) {\n        if (!isWebSocketRequest(request)) {\n            return this.httpHandler.handle(request);\n        }\n        const url = formatUrl(request);\n        const socket = new WebSocket(url);\n        if (!this.sockets[url]) {\n            this.sockets[url] = [];\n        }\n        this.sockets[url].push(socket);\n        socket.binaryType = \"arraybuffer\";\n        this.config = await this.configPromise;\n        const { connectionTimeout = DEFAULT_WS_CONNECTION_TIMEOUT_MS } = this.config;\n        await this.waitForReady(socket, connectionTimeout);\n        const { body } = request;\n        const bodyStream = getIterator(body);\n        const asyncIterable = this.connect(socket, bodyStream);\n        const outputPayload = toReadableStream(asyncIterable);\n        return {\n            response: new HttpResponse({\n                statusCode: 200,\n                body: outputPayload,\n            }),\n        };\n    }\n    updateHttpClientConfig(key, value) {\n        this.configPromise = this.configPromise.then((config) => {\n            config[key] = value;\n            return config;\n        });\n    }\n    httpHandlerConfigs() {\n        return this.config ?? {};\n    }\n    removeNotUsableSockets(url) {\n        this.sockets[url] = (this.sockets[url] ?? []).filter((socket) => ![WebSocket.CLOSING, WebSocket.CLOSED].includes(socket.readyState));\n    }\n    waitForReady(socket, connectionTimeout) {\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                this.removeNotUsableSockets(socket.url);\n                reject({\n                    $metadata: {\n                        httpStatusCode: 500,\n                    },\n                });\n            }, connectionTimeout);\n            socket.onopen = () => {\n                clearTimeout(timeout);\n                resolve();\n            };\n        });\n    }\n    connect(socket, data) {\n        let streamError = undefined;\n        let socketErrorOccurred = false;\n        let reject = () => { };\n        let resolve = () => { };\n        socket.onmessage = (event) => {\n            resolve({\n                done: false,\n                value: new Uint8Array(event.data),\n            });\n        };\n        socket.onerror = (error) => {\n            socketErrorOccurred = true;\n            socket.close();\n            reject(error);\n        };\n        socket.onclose = () => {\n            this.removeNotUsableSockets(socket.url);\n            if (socketErrorOccurred)\n                return;\n            if (streamError) {\n                reject(streamError);\n            }\n            else {\n                resolve({\n                    done: true,\n                    value: undefined,\n                });\n            }\n        };\n        const outputStream = {\n            [Symbol.asyncIterator]: () => ({\n                next: () => {\n                    return new Promise((_resolve, _reject) => {\n                        resolve = _resolve;\n                        reject = _reject;\n                    });\n                },\n            }),\n        };\n        const send = async () => {\n            try {\n                for await (const inputChunk of data) {\n                    socket.send(inputChunk);\n                }\n            }\n            catch (err) {\n                streamError = err;\n            }\n            finally {\n                socket.close(1000);\n            }\n        };\n        send();\n        return outputStream;\n    }\n}\nconst getIterator = (stream) => {\n    if (stream[Symbol.asyncIterator]) {\n        return stream;\n    }\n    if (isReadableStream(stream)) {\n        return readableStreamtoIterable(stream);\n    }\n    return {\n        [Symbol.asyncIterator]: async function* () {\n            yield stream;\n        },\n    };\n};\nconst toReadableStream = (asyncIterable) => typeof ReadableStream === \"function\" ? iterableToReadableStream(asyncIterable) : asyncIterable;\nconst isReadableStream = (payload) => typeof ReadableStream === \"function\" && payload instanceof ReadableStream;\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,0BAA0B;AACpD,SAASC,wBAAwB,EAAEC,wBAAwB,QAAQ,mCAAmC;AACtG,SAASC,gBAAgB,QAAQ,4BAA4B;AAC7D,SAASC,YAAY,QAAQ,uBAAuB;AACpD,SAASC,kBAAkB,QAAQ,SAAS;AAC5C,MAAMC,gCAAgC,GAAG,IAAI;AAC7C,OAAO,MAAMC,qBAAqB,CAAC;EAC/BC,QAAQ,GAAG;IACPC,eAAe,EAAE;EACrB,CAAC;EACDC,MAAM;EACNC,aAAa;EACbC,WAAW;EACXC,OAAO,GAAG,CAAC,CAAC;EACZ,OAAOC,MAAMA,CAACC,iBAAiB,EAAEH,WAAW,GAAG,IAAIT,gBAAgB,CAAC,CAAC,EAAE;IACnE,IAAI,OAAOY,iBAAiB,EAAEC,MAAM,KAAK,UAAU,EAAE;MACjD,OAAOD,iBAAiB;IAC5B;IACA,OAAO,IAAIR,qBAAqB,CAACQ,iBAAiB,EAAEH,WAAW,CAAC;EACpE;EACAK,WAAWA,CAACC,OAAO,EAAEN,WAAW,GAAG,IAAIT,gBAAgB,CAAC,CAAC,EAAE;IACvD,IAAI,CAACS,WAAW,GAAGA,WAAW;IAC9B,IAAI,OAAOM,OAAO,KAAK,UAAU,EAAE;MAC/B,IAAI,CAACR,MAAM,GAAG,CAAC,CAAC;MAChB,IAAI,CAACC,aAAa,GAAGO,OAAO,CAAC,CAAC,CAACC,IAAI,CAAEC,IAAI,IAAM,IAAI,CAACV,MAAM,GAAGU,IAAI,IAAI,CAAC,CAAE,CAAC;IAC7E,CAAC,MACI;MACD,IAAI,CAACV,MAAM,GAAGQ,OAAO,IAAI,CAAC,CAAC;MAC3B,IAAI,CAACP,aAAa,GAAGU,OAAO,CAACC,OAAO,CAAC,IAAI,CAACZ,MAAM,CAAC;IACrD;EACJ;EACAa,OAAOA,CAAA,EAAG;IACN,KAAK,MAAM,CAACC,GAAG,EAAEX,OAAO,CAAC,IAAIY,MAAM,CAACC,OAAO,CAAC,IAAI,CAACb,OAAO,CAAC,EAAE;MACvD,KAAK,MAAMc,MAAM,IAAId,OAAO,EAAE;QAC1Bc,MAAM,CAACC,KAAK,CAAC,IAAI,EAAE,sCAAsC,CAAC;MAC9D;MACA,OAAO,IAAI,CAACf,OAAO,CAACW,GAAG,CAAC;IAC5B;EACJ;EACA,MAAMR,MAAMA,CAACa,OAAO,EAAE;IAClB,IAAI,CAACxB,kBAAkB,CAACwB,OAAO,CAAC,EAAE;MAC9B,OAAO,IAAI,CAACjB,WAAW,CAACI,MAAM,CAACa,OAAO,CAAC;IAC3C;IACA,MAAMC,GAAG,GAAG9B,SAAS,CAAC6B,OAAO,CAAC;IAC9B,MAAMF,MAAM,GAAG,IAAII,SAAS,CAACD,GAAG,CAAC;IACjC,IAAI,CAAC,IAAI,CAACjB,OAAO,CAACiB,GAAG,CAAC,EAAE;MACpB,IAAI,CAACjB,OAAO,CAACiB,GAAG,CAAC,GAAG,EAAE;IAC1B;IACA,IAAI,CAACjB,OAAO,CAACiB,GAAG,CAAC,CAACE,IAAI,CAACL,MAAM,CAAC;IAC9BA,MAAM,CAACM,UAAU,GAAG,aAAa;IACjC,IAAI,CAACvB,MAAM,GAAG,MAAM,IAAI,CAACC,aAAa;IACtC,MAAM;MAAEuB,iBAAiB,GAAG5B;IAAiC,CAAC,GAAG,IAAI,CAACI,MAAM;IAC5E,MAAM,IAAI,CAACyB,YAAY,CAACR,MAAM,EAAEO,iBAAiB,CAAC;IAClD,MAAM;MAAEE;IAAK,CAAC,GAAGP,OAAO;IACxB,MAAMQ,UAAU,GAAGC,WAAW,CAACF,IAAI,CAAC;IACpC,MAAMG,aAAa,GAAG,IAAI,CAACC,OAAO,CAACb,MAAM,EAAEU,UAAU,CAAC;IACtD,MAAMI,aAAa,GAAGC,gBAAgB,CAACH,aAAa,CAAC;IACrD,OAAO;MACHI,QAAQ,EAAE,IAAIvC,YAAY,CAAC;QACvBwC,UAAU,EAAE,GAAG;QACfR,IAAI,EAAEK;MACV,CAAC;IACL,CAAC;EACL;EACAI,sBAAsBA,CAACrB,GAAG,EAAEsB,KAAK,EAAE;IAC/B,IAAI,CAACnC,aAAa,GAAG,IAAI,CAACA,aAAa,CAACQ,IAAI,CAAET,MAAM,IAAK;MACrDA,MAAM,CAACc,GAAG,CAAC,GAAGsB,KAAK;MACnB,OAAOpC,MAAM;IACjB,CAAC,CAAC;EACN;EACAqC,kBAAkBA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACrC,MAAM,IAAI,CAAC,CAAC;EAC5B;EACAsC,sBAAsBA,CAAClB,GAAG,EAAE;IACxB,IAAI,CAACjB,OAAO,CAACiB,GAAG,CAAC,GAAG,CAAC,IAAI,CAACjB,OAAO,CAACiB,GAAG,CAAC,IAAI,EAAE,EAAEmB,MAAM,CAAEtB,MAAM,IAAK,CAAC,CAACI,SAAS,CAACmB,OAAO,EAAEnB,SAAS,CAACoB,MAAM,CAAC,CAACC,QAAQ,CAACzB,MAAM,CAAC0B,UAAU,CAAC,CAAC;EACxI;EACAlB,YAAYA,CAACR,MAAM,EAAEO,iBAAiB,EAAE;IACpC,OAAO,IAAIb,OAAO,CAAC,CAACC,OAAO,EAAEgC,MAAM,KAAK;MACpC,MAAMC,OAAO,GAAGC,UAAU,CAAC,MAAM;QAC7B,IAAI,CAACR,sBAAsB,CAACrB,MAAM,CAACG,GAAG,CAAC;QACvCwB,MAAM,CAAC;UACHG,SAAS,EAAE;YACPC,cAAc,EAAE;UACpB;QACJ,CAAC,CAAC;MACN,CAAC,EAAExB,iBAAiB,CAAC;MACrBP,MAAM,CAACgC,MAAM,GAAG,MAAM;QAClBC,YAAY,CAACL,OAAO,CAAC;QACrBjC,OAAO,CAAC,CAAC;MACb,CAAC;IACL,CAAC,CAAC;EACN;EACAkB,OAAOA,CAACb,MAAM,EAAEkC,IAAI,EAAE;IAClB,IAAIC,WAAW,GAAGC,SAAS;IAC3B,IAAIC,mBAAmB,GAAG,KAAK;IAC/B,IAAIV,MAAM,GAAGA,CAAA,KAAM,CAAE,CAAC;IACtB,IAAIhC,OAAO,GAAGA,CAAA,KAAM,CAAE,CAAC;IACvBK,MAAM,CAACsC,SAAS,GAAIC,KAAK,IAAK;MAC1B5C,OAAO,CAAC;QACJ6C,IAAI,EAAE,KAAK;QACXrB,KAAK,EAAE,IAAIsB,UAAU,CAACF,KAAK,CAACL,IAAI;MACpC,CAAC,CAAC;IACN,CAAC;IACDlC,MAAM,CAAC0C,OAAO,GAAIC,KAAK,IAAK;MACxBN,mBAAmB,GAAG,IAAI;MAC1BrC,MAAM,CAACC,KAAK,CAAC,CAAC;MACd0B,MAAM,CAACgB,KAAK,CAAC;IACjB,CAAC;IACD3C,MAAM,CAAC4C,OAAO,GAAG,MAAM;MACnB,IAAI,CAACvB,sBAAsB,CAACrB,MAAM,CAACG,GAAG,CAAC;MACvC,IAAIkC,mBAAmB,EACnB;MACJ,IAAIF,WAAW,EAAE;QACbR,MAAM,CAACQ,WAAW,CAAC;MACvB,CAAC,MACI;QACDxC,OAAO,CAAC;UACJ6C,IAAI,EAAE,IAAI;UACVrB,KAAK,EAAEiB;QACX,CAAC,CAAC;MACN;IACJ,CAAC;IACD,MAAMS,YAAY,GAAG;MACjB,CAACC,MAAM,CAACC,aAAa,GAAG,OAAO;QAC3BC,IAAI,EAAEA,CAAA,KAAM;UACR,OAAO,IAAItD,OAAO,CAAC,CAACuD,QAAQ,EAAEC,OAAO,KAAK;YACtCvD,OAAO,GAAGsD,QAAQ;YAClBtB,MAAM,GAAGuB,OAAO;UACpB,CAAC,CAAC;QACN;MACJ,CAAC;IACL,CAAC;IACD,MAAMC,IAAI,GAAG,MAAAA,CAAA,KAAY;MACrB,IAAI;QACA,WAAW,MAAMC,UAAU,IAAIlB,IAAI,EAAE;UACjClC,MAAM,CAACmD,IAAI,CAACC,UAAU,CAAC;QAC3B;MACJ,CAAC,CACD,OAAOC,GAAG,EAAE;QACRlB,WAAW,GAAGkB,GAAG;MACrB,CAAC,SACO;QACJrD,MAAM,CAACC,KAAK,CAAC,IAAI,CAAC;MACtB;IACJ,CAAC;IACDkD,IAAI,CAAC,CAAC;IACN,OAAON,YAAY;EACvB;AACJ;AACA,MAAMlC,WAAW,GAAI2C,MAAM,IAAK;EAC5B,IAAIA,MAAM,CAACR,MAAM,CAACC,aAAa,CAAC,EAAE;IAC9B,OAAOO,MAAM;EACjB;EACA,IAAIC,gBAAgB,CAACD,MAAM,CAAC,EAAE;IAC1B,OAAO/E,wBAAwB,CAAC+E,MAAM,CAAC;EAC3C;EACA,OAAO;IACH,CAACR,MAAM,CAACC,aAAa,GAAG,mBAAmB;MACvC,MAAMO,MAAM;IAChB;EACJ,CAAC;AACL,CAAC;AACD,MAAMvC,gBAAgB,GAAIH,aAAa,IAAK,OAAO4C,cAAc,KAAK,UAAU,GAAGlF,wBAAwB,CAACsC,aAAa,CAAC,GAAGA,aAAa;AAC1I,MAAM2C,gBAAgB,GAAIE,OAAO,IAAK,OAAOD,cAAc,KAAK,UAAU,IAAIC,OAAO,YAAYD,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}