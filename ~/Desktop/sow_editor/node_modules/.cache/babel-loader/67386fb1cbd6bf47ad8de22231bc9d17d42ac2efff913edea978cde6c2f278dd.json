{"ast":null,"code":"import { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { dateToUtcString, LazyJsonString, quoteHeader } from \"@smithy/core/serde\";\nimport { toBase64 } from \"@smithy/util-base64\";\nimport { determineTimestampFormat } from \"./determineTimestampFormat\";\nexport class ToStringShapeSerializer {\n  constructor(settings) {\n    this.settings = settings;\n    this.stringBuffer = \"\";\n    this.serdeContext = undefined;\n  }\n  setSerdeContext(serdeContext) {\n    this.serdeContext = serdeContext;\n  }\n  write(schema, value) {\n    const ns = NormalizedSchema.of(schema);\n    switch (typeof value) {\n      case \"object\":\n        if (value === null) {\n          this.stringBuffer = \"null\";\n          return;\n        }\n        if (ns.isTimestampSchema()) {\n          if (!(value instanceof Date)) {\n            throw new Error(`@smithy/core/protocols - received non-Date value ${value} when schema expected Date in ${ns.getName(true)}`);\n          }\n          const format = determineTimestampFormat(ns, this.settings);\n          switch (format) {\n            case SCHEMA.TIMESTAMP_DATE_TIME:\n              this.stringBuffer = value.toISOString().replace(\".000Z\", \"Z\");\n              break;\n            case SCHEMA.TIMESTAMP_HTTP_DATE:\n              this.stringBuffer = dateToUtcString(value);\n              break;\n            case SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n              this.stringBuffer = String(value.getTime() / 1000);\n              break;\n            default:\n              console.warn(\"Missing timestamp format, using epoch seconds\", value);\n              this.stringBuffer = String(value.getTime() / 1000);\n          }\n          return;\n        }\n        if (ns.isBlobSchema() && \"byteLength\" in value) {\n          this.stringBuffer = (this.serdeContext?.base64Encoder ?? toBase64)(value);\n          return;\n        }\n        if (ns.isListSchema() && Array.isArray(value)) {\n          let buffer = \"\";\n          for (const item of value) {\n            this.write([ns.getValueSchema(), ns.getMergedTraits()], item);\n            const headerItem = this.flush();\n            const serialized = ns.getValueSchema().isTimestampSchema() ? headerItem : quoteHeader(headerItem);\n            if (buffer !== \"\") {\n              buffer += \", \";\n            }\n            buffer += serialized;\n          }\n          this.stringBuffer = buffer;\n          return;\n        }\n        this.stringBuffer = JSON.stringify(value, null, 2);\n        break;\n      case \"string\":\n        const mediaType = ns.getMergedTraits().mediaType;\n        let intermediateValue = value;\n        if (mediaType) {\n          const isJson = mediaType === \"application/json\" || mediaType.endsWith(\"+json\");\n          if (isJson) {\n            intermediateValue = LazyJsonString.from(intermediateValue);\n          }\n          if (ns.getMergedTraits().httpHeader) {\n            this.stringBuffer = (this.serdeContext?.base64Encoder ?? toBase64)(intermediateValue.toString());\n            return;\n          }\n        }\n        this.stringBuffer = value;\n        break;\n      default:\n        this.stringBuffer = String(value);\n    }\n  }\n  flush() {\n    const buffer = this.stringBuffer;\n    this.stringBuffer = \"\";\n    return buffer;\n  }\n}","map":{"version":3,"names":["NormalizedSchema","SCHEMA","dateToUtcString","LazyJsonString","quoteHeader","toBase64","determineTimestampFormat","ToStringShapeSerializer","constructor","settings","stringBuffer","serdeContext","undefined","setSerdeContext","write","schema","value","ns","of","isTimestampSchema","Date","Error","getName","format","TIMESTAMP_DATE_TIME","toISOString","replace","TIMESTAMP_HTTP_DATE","TIMESTAMP_EPOCH_SECONDS","String","getTime","console","warn","isBlobSchema","base64Encoder","isListSchema","Array","isArray","buffer","item","getValueSchema","getMergedTraits","headerItem","flush","serialized","JSON","stringify","mediaType","intermediateValue","isJson","endsWith","from","httpHeader","toString"],"sources":["/Users/tuvyakhatter/Desktop/pipecat_voicebot/~/Desktop/sow_editor/node_modules/@smithy/core/dist-es/submodules/protocols/serde/ToStringShapeSerializer.js"],"sourcesContent":["import { NormalizedSchema, SCHEMA } from \"@smithy/core/schema\";\nimport { dateToUtcString, LazyJsonString, quoteHeader } from \"@smithy/core/serde\";\nimport { toBase64 } from \"@smithy/util-base64\";\nimport { determineTimestampFormat } from \"./determineTimestampFormat\";\nexport class ToStringShapeSerializer {\n    constructor(settings) {\n        this.settings = settings;\n        this.stringBuffer = \"\";\n        this.serdeContext = undefined;\n    }\n    setSerdeContext(serdeContext) {\n        this.serdeContext = serdeContext;\n    }\n    write(schema, value) {\n        const ns = NormalizedSchema.of(schema);\n        switch (typeof value) {\n            case \"object\":\n                if (value === null) {\n                    this.stringBuffer = \"null\";\n                    return;\n                }\n                if (ns.isTimestampSchema()) {\n                    if (!(value instanceof Date)) {\n                        throw new Error(`@smithy/core/protocols - received non-Date value ${value} when schema expected Date in ${ns.getName(true)}`);\n                    }\n                    const format = determineTimestampFormat(ns, this.settings);\n                    switch (format) {\n                        case SCHEMA.TIMESTAMP_DATE_TIME:\n                            this.stringBuffer = value.toISOString().replace(\".000Z\", \"Z\");\n                            break;\n                        case SCHEMA.TIMESTAMP_HTTP_DATE:\n                            this.stringBuffer = dateToUtcString(value);\n                            break;\n                        case SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n                            this.stringBuffer = String(value.getTime() / 1000);\n                            break;\n                        default:\n                            console.warn(\"Missing timestamp format, using epoch seconds\", value);\n                            this.stringBuffer = String(value.getTime() / 1000);\n                    }\n                    return;\n                }\n                if (ns.isBlobSchema() && \"byteLength\" in value) {\n                    this.stringBuffer = (this.serdeContext?.base64Encoder ?? toBase64)(value);\n                    return;\n                }\n                if (ns.isListSchema() && Array.isArray(value)) {\n                    let buffer = \"\";\n                    for (const item of value) {\n                        this.write([ns.getValueSchema(), ns.getMergedTraits()], item);\n                        const headerItem = this.flush();\n                        const serialized = ns.getValueSchema().isTimestampSchema() ? headerItem : quoteHeader(headerItem);\n                        if (buffer !== \"\") {\n                            buffer += \", \";\n                        }\n                        buffer += serialized;\n                    }\n                    this.stringBuffer = buffer;\n                    return;\n                }\n                this.stringBuffer = JSON.stringify(value, null, 2);\n                break;\n            case \"string\":\n                const mediaType = ns.getMergedTraits().mediaType;\n                let intermediateValue = value;\n                if (mediaType) {\n                    const isJson = mediaType === \"application/json\" || mediaType.endsWith(\"+json\");\n                    if (isJson) {\n                        intermediateValue = LazyJsonString.from(intermediateValue);\n                    }\n                    if (ns.getMergedTraits().httpHeader) {\n                        this.stringBuffer = (this.serdeContext?.base64Encoder ?? toBase64)(intermediateValue.toString());\n                        return;\n                    }\n                }\n                this.stringBuffer = value;\n                break;\n            default:\n                this.stringBuffer = String(value);\n        }\n    }\n    flush() {\n        const buffer = this.stringBuffer;\n        this.stringBuffer = \"\";\n        return buffer;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}