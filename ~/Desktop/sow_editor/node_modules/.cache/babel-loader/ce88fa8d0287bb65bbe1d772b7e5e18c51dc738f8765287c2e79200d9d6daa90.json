{"ast":null,"code":"export function map(arg0, arg1, arg2) {\n  let target;\n  let filter;\n  let instructions;\n  if (typeof arg1 === \"undefined\" && typeof arg2 === \"undefined\") {\n    target = {};\n    instructions = arg0;\n  } else {\n    target = arg0;\n    if (typeof arg1 === \"function\") {\n      filter = arg1;\n      instructions = arg2;\n      return mapWithFilter(target, filter, instructions);\n    } else {\n      instructions = arg1;\n    }\n  }\n  for (const key of Object.keys(instructions)) {\n    if (!Array.isArray(instructions[key])) {\n      target[key] = instructions[key];\n      continue;\n    }\n    applyInstruction(target, null, instructions, key);\n  }\n  return target;\n}\nexport const convertMap = target => {\n  const output = {};\n  for (const [k, v] of Object.entries(target || {})) {\n    output[k] = [, v];\n  }\n  return output;\n};\nexport const take = (source, instructions) => {\n  const out = {};\n  for (const key in instructions) {\n    applyInstruction(out, source, instructions, key);\n  }\n  return out;\n};\nconst mapWithFilter = (target, filter, instructions) => {\n  return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {\n    if (Array.isArray(value)) {\n      _instructions[key] = value;\n    } else {\n      if (typeof value === \"function\") {\n        _instructions[key] = [filter, value()];\n      } else {\n        _instructions[key] = [filter, value];\n      }\n    }\n    return _instructions;\n  }, {}));\n};\nconst applyInstruction = (target, source, instructions, targetKey) => {\n  if (source !== null) {\n    let instruction = instructions[targetKey];\n    if (typeof instruction === \"function\") {\n      instruction = [, instruction];\n    }\n    const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;\n    if (typeof filter === \"function\" && filter(source[sourceKey]) || typeof filter !== \"function\" && !!filter) {\n      target[targetKey] = valueFn(source[sourceKey]);\n    }\n    return;\n  }\n  let [filter, value] = instructions[targetKey];\n  if (typeof value === \"function\") {\n    let _value;\n    const defaultFilterPassed = filter === undefined && (_value = value()) != null;\n    const customFilterPassed = typeof filter === \"function\" && !!filter(void 0) || typeof filter !== \"function\" && !!filter;\n    if (defaultFilterPassed) {\n      target[targetKey] = _value;\n    } else if (customFilterPassed) {\n      target[targetKey] = value();\n    }\n  } else {\n    const defaultFilterPassed = filter === undefined && value != null;\n    const customFilterPassed = typeof filter === \"function\" && !!filter(value) || typeof filter !== \"function\" && !!filter;\n    if (defaultFilterPassed || customFilterPassed) {\n      target[targetKey] = value;\n    }\n  }\n};\nconst nonNullish = _ => _ != null;\nconst pass = _ => _;","map":{"version":3,"names":["map","arg0","arg1","arg2","target","filter","instructions","mapWithFilter","key","Object","keys","Array","isArray","applyInstruction","convertMap","output","k","v","entries","take","source","out","reduce","_instructions","value","targetKey","instruction","nonNullish","valueFn","pass","sourceKey","_value","defaultFilterPassed","undefined","customFilterPassed","_"],"sources":["/Users/tuvyakhatter/Desktop/pipecat_voicebot/~/Desktop/sow_editor/node_modules/@smithy/smithy-client/dist-es/object-mapping.js"],"sourcesContent":["export function map(arg0, arg1, arg2) {\n    let target;\n    let filter;\n    let instructions;\n    if (typeof arg1 === \"undefined\" && typeof arg2 === \"undefined\") {\n        target = {};\n        instructions = arg0;\n    }\n    else {\n        target = arg0;\n        if (typeof arg1 === \"function\") {\n            filter = arg1;\n            instructions = arg2;\n            return mapWithFilter(target, filter, instructions);\n        }\n        else {\n            instructions = arg1;\n        }\n    }\n    for (const key of Object.keys(instructions)) {\n        if (!Array.isArray(instructions[key])) {\n            target[key] = instructions[key];\n            continue;\n        }\n        applyInstruction(target, null, instructions, key);\n    }\n    return target;\n}\nexport const convertMap = (target) => {\n    const output = {};\n    for (const [k, v] of Object.entries(target || {})) {\n        output[k] = [, v];\n    }\n    return output;\n};\nexport const take = (source, instructions) => {\n    const out = {};\n    for (const key in instructions) {\n        applyInstruction(out, source, instructions, key);\n    }\n    return out;\n};\nconst mapWithFilter = (target, filter, instructions) => {\n    return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {\n        if (Array.isArray(value)) {\n            _instructions[key] = value;\n        }\n        else {\n            if (typeof value === \"function\") {\n                _instructions[key] = [filter, value()];\n            }\n            else {\n                _instructions[key] = [filter, value];\n            }\n        }\n        return _instructions;\n    }, {}));\n};\nconst applyInstruction = (target, source, instructions, targetKey) => {\n    if (source !== null) {\n        let instruction = instructions[targetKey];\n        if (typeof instruction === \"function\") {\n            instruction = [, instruction];\n        }\n        const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;\n        if ((typeof filter === \"function\" && filter(source[sourceKey])) || (typeof filter !== \"function\" && !!filter)) {\n            target[targetKey] = valueFn(source[sourceKey]);\n        }\n        return;\n    }\n    let [filter, value] = instructions[targetKey];\n    if (typeof value === \"function\") {\n        let _value;\n        const defaultFilterPassed = filter === undefined && (_value = value()) != null;\n        const customFilterPassed = (typeof filter === \"function\" && !!filter(void 0)) || (typeof filter !== \"function\" && !!filter);\n        if (defaultFilterPassed) {\n            target[targetKey] = _value;\n        }\n        else if (customFilterPassed) {\n            target[targetKey] = value();\n        }\n    }\n    else {\n        const defaultFilterPassed = filter === undefined && value != null;\n        const customFilterPassed = (typeof filter === \"function\" && !!filter(value)) || (typeof filter !== \"function\" && !!filter);\n        if (defaultFilterPassed || customFilterPassed) {\n            target[targetKey] = value;\n        }\n    }\n};\nconst nonNullish = (_) => _ != null;\nconst pass = (_) => _;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}